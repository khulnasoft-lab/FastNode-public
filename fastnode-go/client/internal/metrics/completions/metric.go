package completions

// # Overview
// The new code lives in `completions/metrics.go`.
//
// A *completion* is uniquely identified by the final state of the buffer if the completion were to be
// selected as well as the cursor position post-selection. This is tracked as a *targetBuffer*.
// We keep track of the targetBuffers from the last time completions were returned.
// Each shownInstance of a completion has a *rank*, which is where in the returned list of completions it was shown.
//
// We track metrics for selected completions.
// Selected completions are those which were likely selected from the completions dropdown by the user.
//	   * a completion is selected if the current buffer matches one of the targetBuffers from the latest set of completions returned.
//     * this may be a subset of completed completions.
//     * there may be false positives here: if the user fully types out the completion, the last seen completions will include a shownInstance
//       typically just before the final character, and if the user just types the final character, we still consider
//       the completion selected.
//
// For each tracked completion, we track its rank, length, and number of characters inserted.
// This allows us to do some post-processing & analysis of the data on segment (such as ignoring completions
// where the number of inserted characters is 1).
//
// # Assumptions
// 1. completions requests & buffer edits are received in order; based on my testing, this seems to be the case
//    (almost) always for Fastnode Local; in the rare case that this may not hold, I posit that the resulting metrics
//    blip is acceptable in return for cleaner code.
// 2. a *single* buffer edit event is sent when the user selects a completion from the dropdown; this isn't a hard
//    requirement, but the `NumSelected` value being useful depends on this. Again, I tested this on all editors
//    except vim, and it appears to be true.
//
// # Extensions
// We can easily extend this framework in various ways. An obvious augmentation would be to track the last
// shownInstance of a completion and ranks in previous shownInstances. This might be useful, since it's
// possible a completion isn't selected until its rank becomes sufficiently high. It might be sufficient to just
// additionally track the first shownInstance for this sort of analysis.

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"hash/fnv"
	"log"
	"math/rand"
	"strconv"
	"strings"
	"sync"
	"time"
	"unicode/utf8"

	"github.com/khulnasoft-lab/fastnode/fastnode-go/client/internal/clienttelemetry"
	"github.com/khulnasoft-lab/fastnode/fastnode-go/lang"
	"github.com/khulnasoft-lab/fastnode/fastnode-go/lang/lexical/lexicalcomplete/lexicalproviders"
	"github.com/khulnasoft-lab/fastnode/fastnode-go/lang/python/pythonscanner"
	"github.com/khulnasoft-lab/fastnode/fastnode-go/response"
	"github.com/khulnasoft-lab/fastnode/fastnode-golib/complete/data"
	"github.com/khulnasoft-lab/fastnode/fastnode-golib/lexicalv0"
	"github.com/khulnasoft-lab/fastnode/fastnode-golib/lexicalv0/lexer"
	"github.com/khulnasoft-lab/fastnode/fastnode-golib/rollbar"
	"github.com/khulnasoft-lab/fastnode/fastnode-golib/stringindex"
)

const (
	durationMsBucketSize = 10  // 10 ms buckets
	durationMsMaxBucket  = 150 // everything greater than 150ms is grouped into a single bucket
	shownSampleRate      = 0.1
)

// CompletedInfo encapsulates a completion's rank, length, and number of characters inserted
// Note that we don't currently serialize individual instances of this field anywhere; we just send aggregations
// TODO: send individual completed/selected samples in an event that's not fastnode_status
type CompletedInfo struct {
	// some fields are json CamelCase to maintain backwards compatibility for consumers
	// TODO(naman) rename Source, Rank, Len, NumInserted

	Source      response.EditorCompletionSource
	Provider    data.ProviderName
	Rank        int
	Len         int
	NumInserted int

	// num chars/tokens inserted since last shown
	NumTokensInserted int `json:"num_tokens_inserted"`
}

// EngineMetrics contains counts of completion request metrics that are generated by the completions engine, for
// a particular language
type EngineMetrics struct {
	// Aggregated Metrics
	RequestsReceived          int
	RequestsAccepted          int
	RequestsAcceptedNewToken  int
	RequestsFulfilled         int
	RequestsFulfilledNewToken int

	// Unit Metrics
	AcceptedPerProvider          map[data.ProviderName]int
	AcceptedPerProviderNewToken  map[data.ProviderName]int
	FulfilledPerProvider         map[data.ProviderName]int
	FulfilledPerProviderNewToken map[data.ProviderName]int
}

func newEngineMetrics() EngineMetrics {
	return EngineMetrics{
		AcceptedPerProvider:          make(map[data.ProviderName]int),
		AcceptedPerProviderNewToken:  make(map[data.ProviderName]int),
		FulfilledPerProvider:         make(map[data.ProviderName]int),
		FulfilledPerProviderNewToken: make(map[data.ProviderName]int),
	}
}

func (r EngineMetrics) flatten(l lang.Language, out map[string]interface{}) {
	write := func(k string, val interface{}) {
		if val, ok := val.(int); ok && val == 0 {
			// save space by not writing 0 values
			return
		}
		out[k] = val
	}

	write(fmt.Sprintf("%s_completions_request_received", l.Name()), r.RequestsReceived)
	write(fmt.Sprintf("%s_completions_request_accepted", l.Name()), r.RequestsAccepted)
	write(fmt.Sprintf("%s_completions_starting_request_accepted", l.Name()), r.RequestsAcceptedNewToken)
	write(fmt.Sprintf("%s_completions_request_fulfilled", l.Name()), r.RequestsFulfilled)
	write(fmt.Sprintf("%s_completions_starting_request_fulfilled", l.Name()), r.RequestsFulfilledNewToken)

	for p, count := range r.AcceptedPerProvider {
		write(fmt.Sprintf("%s_%s_completions_request_accepted", l.Name(), p.String()), count)
	}

	for p, count := range r.AcceptedPerProviderNewToken {
		write(fmt.Sprintf("%s_%s_completions_starting_request_accepted", l.Name(), p.String()), count)
	}

	for p, count := range r.FulfilledPerProvider {
		write(fmt.Sprintf("%s_%s_completions_request_fulfilled", l.Name(), p.String()), count)
	}

	for p, count := range r.FulfilledPerProviderNewToken {
		write(fmt.Sprintf("%s_%s_completions_starting_request_fulfilled", l.Name(), p.String()), count)
	}
}

// GetEngineMetricsCallback returns a standard EngineMetricsCallback that increments the relevant counts in a Metrics object
func (m *Metrics) GetEngineMetricsCallback(isNewTokenInsertion bool) data.EngineMetricsCallback {
	return func(acceptedProviders map[data.ProviderName]struct{}, fulfilledProviders map[data.ProviderName]struct{}) {
		m.m.Lock()
		defer m.m.Unlock()

		accepted := false
		for p := range acceptedProviders {
			accepted = true
			m.stats.EngineMetrics.AcceptedPerProvider[p]++
			if isNewTokenInsertion {
				m.stats.EngineMetrics.AcceptedPerProviderNewToken[p]++
			}
		}
		if accepted {
			m.stats.EngineMetrics.RequestsAccepted++
			if isNewTokenInsertion {
				m.stats.EngineMetrics.RequestsAcceptedNewToken++
			}
		}

		fulfilled := false
		for p := range fulfilledProviders {
			fulfilled = true
			m.stats.EngineMetrics.FulfilledPerProvider[p]++
			if isNewTokenInsertion {
				m.stats.EngineMetrics.FulfilledPerProviderNewToken[p]++
			}
		}
		if fulfilled {
			m.stats.EngineMetrics.RequestsFulfilled++
			if isNewTokenInsertion {
				m.stats.EngineMetrics.RequestsFulfilledNewToken++
			}
		}
	}
}

// ReportedCompletionMetrics contains counts of completion metrics that the editors have reported to fastnoded for one
// language
type ReportedCompletionMetrics struct {
	TotalSelected      int
	TotalWordsInserted int

	SelectedPerEditor        map[data.Editor]int
	SelectedPerProvider      map[data.ProviderName]int
	InsertedWordsPerProvider map[data.ProviderName]int
}

func newReportedCompletionMetrics() ReportedCompletionMetrics {
	return ReportedCompletionMetrics{
		SelectedPerEditor:        make(map[data.Editor]int),
		SelectedPerProvider:      make(map[data.ProviderName]int),
		InsertedWordsPerProvider: make(map[data.ProviderName]int),
	}
}

func (r ReportedCompletionMetrics) flatten(l lang.Language, out map[string]interface{}) {
	write := func(k string, val interface{}) {
		if val, ok := val.(int); ok && val == 0 {
			// save space by not writing 0 values
			return
		}
		out[k] = val
	}

	write(fmt.Sprintf("%s_completions_selected", l.Name()), r.TotalSelected)
	write(fmt.Sprintf("%s_completions_words_inserted", l.Name()), r.TotalWordsInserted)

	for editor, count := range r.SelectedPerEditor {
		write(fmt.Sprintf("%s_%s_completions_selected", editor.String(), l.Name()), count)
	}

	for p, count := range r.SelectedPerProvider {
		write(fmt.Sprintf("%s_%s_completions_selected", l.Name(), p.String()), count)
	}

	for p, count := range r.InsertedWordsPerProvider {
		write(fmt.Sprintf("%s_%s_completions_words_inserted", l.Name(), p.String()), count)
	}
}

// RequestCounts contains counts of requests made for completions
type RequestCounts struct {
	Total      int // number of total requests
	Expected   int // number of expected requests
	Unexpected int // number of unexpected requests
	Error      int // number of requests that resulted in an error

}

// SourceBreakdown describes a breakdown of counts by completions source.
type SourceBreakdown map[response.EditorCompletionSource]int

// Snapshot captures a snapshot of the statistics collected by this metric
type Snapshot struct {
	Requested    RequestCounts // breakdown of number of requests made for a changed buffer state
	RequestedRaw RequestCounts // breakdown of number of requests made, without buffer state deduplication

	Triggered          int // number of times completions were triggered for a changed buffer state
	Shown              int // number of unique completions that were shown
	AtLeastOneShown    int // number of times at least one completion was shown
	AtLeastOneNewShown int // number of times at least one new completion was shown
	NumSelected        int // total number of selected completions

	// number of unique completions shown by source
	ShownBySource SourceBreakdown
	// number of times at least one completion was shown, by source
	AtLeastOneShownBySource SourceBreakdown
	// number of times at least one new completion was shown, by source
	AtLeastOneNewShownBySource SourceBreakdown

	// SelectedBySource contains counts of selected completions by source
	SelectedBySource SourceBreakdown
	// Selected2BySource contains counts of selected completions, where at least 2 characters were inserted
	// during the selection, by source
	Selected2BySource SourceBreakdown

	DurationHistogram map[int64]uint

	// MatchedByProvider contains counts of completions that were matched (i.e. we infer they were selected),
	// by Provider
	MatchedByProvider map[data.ProviderName]int

	// EngineMetrics contains counts of completion request metrics that are kept track of within fastnoded
	EngineMetrics EngineMetrics

	// ReportedCounts contains counts of completion metrics as they have been reported by editors
	ReportedCounts ReportedCompletionMetrics
}

func newSnapshot() Snapshot {
	return Snapshot{
		ShownBySource:              make(SourceBreakdown),
		AtLeastOneShownBySource:    make(SourceBreakdown),
		AtLeastOneNewShownBySource: make(SourceBreakdown),
		SelectedBySource:           make(SourceBreakdown),
		Selected2BySource:          make(SourceBreakdown),
		DurationHistogram:          make(map[int64]uint, durationMsMaxBucket/durationMsBucketSize+1),
		MatchedByProvider:          make(map[data.ProviderName]int),
		EngineMetrics:              newEngineMetrics(),
		ReportedCounts:             newReportedCompletionMetrics(),
	}
}

func (s *Snapshot) addSelected(new CompletedInfo) {
	s.NumSelected++
	s.SelectedBySource[new.Source]++
	s.MatchedByProvider[new.Provider]++
	if new.NumInserted >= 2 {
		s.Selected2BySource[new.Source]++
	}
}

func (s Snapshot) flatten(l lang.Language, out map[string]interface{}) {
	var prefix string
	switch l {
	case lang.Python:
		// This is for backwards compatibility reasons (python came first)
		prefix = ""
	default:
		prefix = l.Name() + "_"
	}
	write := func(k string, val interface{}) {
		if val, ok := val.(int); ok && val == 0 {
			// save space by not writing 0 values
			return
		}
		out[k] = val
	}
	write(prefix+"completions_requested", s.Requested.Total)
	write(prefix+"completions_requested_expected", s.Requested.Expected)
	write(prefix+"completions_requested_unexpected", s.Requested.Unexpected)
	write(prefix+"completions_requested_error", s.Requested.Error)

	write(prefix+"completions_requested_raw", s.RequestedRaw.Total)
	write(prefix+"completions_requested_expected_raw", s.RequestedRaw.Expected)
	write(prefix+"completions_requested_unexpected_raw", s.RequestedRaw.Unexpected)
	write(prefix+"completions_requested_error_raw", s.RequestedRaw.Error)

	write(prefix+"completions_triggered", s.Triggered)
	write(prefix+"completions_shown", s.Shown)
	write(prefix+"completions_at_least_one_shown", s.AtLeastOneShown)
	write(prefix+"completions_at_least_one_new_shown", s.AtLeastOneNewShown)

	// Old version
	write(prefix+"completions_num_selected", s.NumSelected)
	// New version
	write(fmt.Sprintf("%s_completions_matched", l.Name()), s.NumSelected)

	for p, count := range s.MatchedByProvider {
		write(fmt.Sprintf("%s_%s_completions_matched", l.Name(), p.String()), count)
	}

	write(prefix+"completions_selected_by_source", s.SelectedBySource)
	write(prefix+"completions_selected_2_by_source", s.Selected2BySource)

	write(prefix+"completions_shown_by_source", s.ShownBySource)
	write(prefix+"completions_at_least_one_shown_by_source", s.AtLeastOneShownBySource)
	write(prefix+"completions_at_least_one_new_shown_by_source", s.AtLeastOneNewShownBySource)

	histogram := make(map[string]uint)
	for msLower, count := range s.DurationHistogram {
		msLowerStr := strconv.Itoa(int(msLower))

		var key string
		if msLower == durationMsMaxBucket {
			key = msLowerStr + "_"
		} else {
			msUpperStr := strconv.Itoa(int(msLower + durationMsBucketSize - 1))
			key = msLowerStr + "_" + msUpperStr
		}
		histogram[key] = count
	}
	write(prefix+"completions_duration_hist", histogram)

	s.EngineMetrics.flatten(l, out)
	s.ReportedCounts.flatten(l, out)
}

// MetricsByLang tracks metric sharded by language
type MetricsByLang struct {
	m sync.Map
}

// NewMetrics returns a new MetricsByLang
func NewMetrics() *MetricsByLang {
	return &MetricsByLang{}
}

// Get gets the metrics object for a given language
func (ms *MetricsByLang) Get(l lang.Language) *Metrics {
	if ms == nil {
		return nil
	}

	shard, ok := ms.m.Load(l)
	if !ok {
		m := &Metrics{
			s:     newBufferState(),
			stats: newSnapshot(),
			lang:  l,
		}
		shard, _ = ms.m.LoadOrStore(l, m)
	}
	return shard.(*Metrics)
}

// ReadAndFlatten metrics to send
func (ms *MetricsByLang) ReadAndFlatten(clear bool, out map[string]interface{}) map[string]interface{} {
	if out == nil {
		out = make(map[string]interface{})
	}
	ms.m.Range(func(k, v interface{}) bool {
		l := k.(lang.Language)
		m := v.(*Metrics)
		m.read(clear).flatten(l, out)
		return true
	})
	return out
}

// Flush flushes the metrics for each language
func (ms *MetricsByLang) Flush() {
	ms.m.Range(func(k, v interface{}) bool {
		m := v.(*Metrics)
		m.flush()
		return true
	})
}

// Metrics records the number of completions used, out of those suggested by fastnode.
type Metrics struct {
	m          sync.Mutex
	s          *bufferState
	stats      Snapshot
	lang       lang.Language
	cLock      sync.Mutex
	complStats []CompletionStat
}

// Read returns the current count
func (m *Metrics) read(clear bool) Snapshot {
	m.m.Lock()
	defer m.m.Unlock()

	out := m.stats

	if clear {
		m.stats = newSnapshot()
		m.s.shown = make(map[targetBuffer]struct{})
		return out
	}

	// copy slices and maps to avoid data races
	copyBreakdown := func(src SourceBreakdown) SourceBreakdown {
		ret := make(SourceBreakdown, len(src))
		for k, v := range src {
			ret[k] = v
		}
		return ret
	}
	out.ShownBySource = copyBreakdown(out.ShownBySource)
	out.AtLeastOneShownBySource = copyBreakdown(out.AtLeastOneShownBySource)
	out.AtLeastOneNewShownBySource = copyBreakdown(out.AtLeastOneNewShownBySource)
	out.SelectedBySource = copyBreakdown(out.SelectedBySource)
	out.Selected2BySource = copyBreakdown(out.Selected2BySource)

	return out
}

// Requested is called when completions are requested by the user
func (m *Metrics) Requested() {
	if m == nil {
		return
	}

	m.m.Lock()
	defer m.m.Unlock()

	m.stats.RequestedRaw.Total++

	if !m.s.eventsSeen.requested {
		m.stats.Requested.Total++
	}
	m.s.eventsSeen.requested = true

	m.stats.EngineMetrics.RequestsReceived++
}

// Expected is called when a response is received to record whether or not the original request was expected
func (m *Metrics) Expected(expected bool) {
	if m == nil {
		return
	}

	m.m.Lock()
	defer m.m.Unlock()

	if expected {
		m.stats.RequestedRaw.Expected++
		if !m.s.eventsSeen.requestedExpected {
			m.stats.Requested.Expected++
		}
		m.s.eventsSeen.requestedExpected = true

	} else {
		m.stats.RequestedRaw.Unexpected++
		if !m.s.eventsSeen.requestedUnexpected {
			m.stats.Requested.Unexpected++
		}
		m.s.eventsSeen.requestedUnexpected = true
	}
}

// Errored is called when there was an error obtaining completions
func (m *Metrics) Errored() {
	if m == nil {
		return
	}

	m.m.Lock()
	defer m.m.Unlock()

	m.stats.RequestedRaw.Error++
	if !m.s.eventsSeen.requestedError {
		m.stats.Requested.Error++
	}
	m.s.eventsSeen.requestedError = true
}

// ReturnedCompat is a backwards compatible wrapper around Returned
func (m *Metrics) ReturnedCompat(text string, cursor int, legacy []response.EditorCompletion, start time.Time) {
	if m == nil {
		return
	}

	var compls []data.NRCompletion
	for _, compl := range legacy {
		start := legacyComplStart(text, cursor, compl.Insert)
		rc := data.RCompletion{
			Completion: data.Completion{
				Snippet: data.Snippet{Text: compl.Insert},
				Replace: data.Selection{Begin: start, End: cursor},
			},
			Source: compl.Source,
		}
		compls = append(compls, data.NRCompletion{RCompletion: rc})
	}

	resp := data.NewAPIResponse(data.APIRequest{
		SelectedBuffer: data.NewBuffer(text).Select(data.Cursor(cursor)),
	})
	resp.Completions = compls
	m.Returned(resp, start)
}

// Returned is called when completions are sent to the user
func (m *Metrics) Returned(resp data.APIResponse, start time.Time) {
	if m == nil {
		return
	}

	resp.EncodeOffsets(stringindex.Native)
	sb := resp.Request.SelectedBuffer
	compls := resp.Completions

	duration := time.Since(start)

	m.m.Lock()
	defer m.m.Unlock()

	if len(compls) > 0 {
		bucket := int64(duration/time.Millisecond) / durationMsBucketSize * durationMsBucketSize
		if bucket > durationMsMaxBucket {
			bucket = durationMsMaxBucket
		}
		m.stats.DurationHistogram[bucket]++
	}

	if sb.End > sb.Begin {
		return
	}
	cursor := sb.Begin
	text := sb.Text()

	if cursor < 0 || cursor > len(text) {
		rollbar.Error(fmt.Errorf("cursor out of bounds"))
		return
	}

	m.updateLocked(buffer{data.NewBuffer(text).Select(data.Cursor(cursor))})

	if !m.s.eventsSeen.triggered {
		m.stats.Triggered++
	}
	m.s.eventsSeen.triggered = true

	sources := make(map[response.EditorCompletionSource]struct{})
	for _, c := range compls {
		sources[c.Source] = struct{}{}
	}

	var totalAtLeastOne int
	for source := range sources {
		if _, found := m.s.eventsSeen.atLeastOneShown[source]; !found {
			m.stats.AtLeastOneShownBySource[source]++
			totalAtLeastOne++
		}
		m.s.eventsSeen.atLeastOneShown[source] = true
	}

	if totalAtLeastOne > 0 {
		m.stats.AtLeastOneShown++
	}

	var shown int
	newSources := make(map[response.EditorCompletionSource]struct{})
	for rank, compl := range compls {
		if isNew, inst := m.s.add(compl.RCompletion, rank); isNew {
			m.recordStat(inst, completionShown)
			shown++
			newSources[compl.Source] = struct{}{}
			m.stats.ShownBySource[compl.Source]++
		}
	}
	m.stats.Shown += shown
	if shown > 0 {
		m.stats.AtLeastOneNewShown++
	}
	for source := range newSources {
		m.stats.AtLeastOneNewShownBySource[source]++
	}
}

// BufferEdited is called when we receive the contents of the buffer,
// NOTE: `cursor` must be the byte offset (from the beginning of the `text`) to the current cursor position.
func (m *Metrics) BufferEdited(text string, cursor int) {
	if m == nil {
		return
	}

	m.m.Lock()
	defer m.m.Unlock()

	if cursor < 0 || cursor > len(text) {
		rollbar.Error(fmt.Errorf("cursor out of bounds"))
		return
	}

	m.updateLocked(buffer{data.NewBuffer(text).Select(data.Cursor(cursor))})
}

// CompletionSelectedEvent is a completion selection event sent from editors to fastnoded
type CompletionSelectedEvent struct {
	Editor     data.Editor      `json:"editor"`
	Language   string           `json:"language"`
	Completion data.RCompletion `json:"completion"`
}

// CompletionSelected is called when we receive a completion selected event
func (m *Metrics) CompletionSelected(cs CompletionSelectedEvent) {
	m.m.Lock()
	defer m.m.Unlock()

	compl := cs.Completion
	editor := cs.Editor

	m.stats.ReportedCounts.TotalSelected++
	m.stats.ReportedCounts.SelectedPerProvider[compl.Provider]++
	m.stats.ReportedCounts.SelectedPerEditor[editor]++

	wordCount := numWords(compl.Snippet.Text, m.lang)
	m.stats.ReportedCounts.TotalWordsInserted += wordCount
	m.stats.ReportedCounts.InsertedWordsPerProvider[compl.Provider] += wordCount
}

// -

func legacyComplStart(text string, cursor int, complText string) int {
	testPos := cursor
	start := testPos
	for start > 0 {
		r, sz := utf8.DecodeLastRuneInString(text[:testPos])
		if r == utf8.RuneError {
			// TODO(naman) track this in metrics?
			log.Printf("could not decode rune in completionsmetrics")
			return cursor
		}
		testPos -= sz

		testSuffix := text[testPos:cursor]
		idx := strings.Index(complText, testSuffix)
		if idx < 0 || testPos < idx { // TODO(naman) why do we need the second disjunct? leave a comment here
			break
		}

		// the first match of testSuffix is at position idx, so if there is a valid overlap, it must start at testPos-idx
		testPos -= idx
		testSuffix = text[testPos:cursor]
		if strings.HasPrefix(complText, testSuffix) {
			start = testPos
		}
	}
	return start
}

func (m *Metrics) updateLocked(b buffer) {
	completion := m.s.update(b)
	if completion == nil {
		return
	}
	log.Printf("%s completion selection inferred", m.lang.Name())
	m.recordStat(completion, completionSelected)
	inserted := completion.toInsert()
	cs := CompletedInfo{
		Rank:        completion.rank,
		Len:         len(completion.text),
		NumInserted: len(inserted),
		Source:      completion.source,
		Provider:    completion.provider,

		NumTokensInserted: numTokens(inserted, m.lang),
		// TODO(naman) NumTokensFirstShown: c.numTokensFirstShown,
	}
	m.stats.addSelected(cs)
}

// --

type buffer struct {
	data.SelectedBuffer // we assume the Selection is just a fixed cursor for now
}

// targetBuffer encapsulates a "logical" completion, represented by the final "target" buffer state resulting from completing a completion
type targetBuffer struct {
	hash   uint64 // hash of entire buffer, post-completion
	cursor int    // cursor position, post-completion
}

// shownInstance encapsulates information about how & when a completion was shown
type shownInstance struct {
	// text of the completion, potentially including already typed (case-insensitive) characters
	text string
	// source is where the completion was generated
	source response.EditorCompletionSource
	// provider that provided the completion
	provider data.ProviderName
	// rank in the list of completions returned to the editor
	rank int
	// cursor position when the completion was shown
	cursor int
	// start position of the completion text in the buffer
	start int
	// end position of the completion text in the buffer
	end int
	// replacedText is the text being replaced by the completion
	replacedText string
	// placeholderChars is the total sum of chars in the snippet placeholders
	placeholderChars int
	// lexical indicates whether this represents a lexical completion
	lexical bool
	// lexicalMetrics contains lexical-specific metrics
	lexicalMetrics *lexicalproviders.LexicalMetrics
}

type completionStatus string
type completionType string

const (
	invalidStatus completionStatus = "invalid"
	validStatus   completionStatus = "valid"

	completionShown    completionType = "shown"
	completionSelected completionType = "selected"
)

func (i shownInstance) toInsert() string {
	progress := i.progress()
	if progress > len(i.text) {
		return ""
	}
	return i.text[progress:]
}

func (i shownInstance) progress() int {
	return i.cursor - i.start
}

func (b buffer) shownInstance(compl data.RCompletion, rank int) *shownInstance {
	phChars := 0
	for _, ph := range compl.Snippet.Placeholders() {
		phChars += ph.Len()
	}

	instance := &shownInstance{
		text:             compl.Snippet.Text,
		source:           compl.Source,
		provider:         compl.Provider,
		rank:             rank,
		cursor:           b.Selection.Begin,
		start:            compl.Replace.Begin,
		end:              compl.Replace.End,
		replacedText:     b.TextAt(compl.Replace),
		placeholderChars: phChars,
	}

	if metrics, ok := compl.Metrics.(*lexicalproviders.LexicalMetrics); ok {
		instance.lexical = true
		instance.lexicalMetrics = metrics
	}

	return instance
}

func (b buffer) targetBuffer(i *shownInstance) targetBuffer {
	text := b.TextAt(data.Selection{End: i.start}) + i.text + b.TextAt(data.Selection{Begin: i.end, End: b.Buffer.Len()})
	return targetBuffer{
		hash: hash(text),
	}
}

func (b buffer) status(target targetBuffer, last *shownInstance) completionStatus {
	if b.Selection.Begin < last.cursor {
		// cursor moved backwards
		return invalidStatus
	}

	text := b.TextAt(data.Selection{End: last.start}) + last.text + b.TextAt(data.Selection{Begin: last.end, End: b.Buffer.Len()})
	if target.hash != hash(text) {
		// contents of buffer before cursor changed, accounting for difference
		return invalidStatus
	}

	return validStatus
}

// - tracking

// max number of completion stats to record before sending:
// as of 2019-11-13, the completion selected(2) per shown rate is ~15%,
// so we'd send an event every 150/.15 = 1000 times completions are shown.
//
// Ammendment: This was cut in half to 75 after the addition of `Lexical` and
// `LexicalMetrics` to CompletionStat, as they roughly doubled the size of the object
var maxStats = 75

// CompletionStat encapsulates the information for a completion that is shown or selected
type CompletionStat struct {
	Language       lang.Language  `json:"language"`
	CompletionType completionType `json:"completion_type"`
	Source         string         `json:"source"`
	Rank           int            `json:"rank"`
	// counts for insertion text (stripped of prefix/suffix matches)
	NumCharsInserted  int `json:"num_chars_inserted"`
	NumTokensInserted int `json:"num_tokens_inserted"` // includes EOF
	// counts for buffer text being replaced
	NumCharsReplaced  int `json:"num_chars_replaced"`
	NumTokensReplaced int `json:"num_tokens_replaced"` // includes EOF
	// total number of characters in the placeholders
	NumPlaceholderChars int `json:"num_placeholder_chars"`

	Lexical        bool                             `json:"is_lexical"`
	LexicalMetrics *lexicalproviders.LexicalMetrics `json:"lexical_metrics,omitempty"` // omitempty saves some space
}

type eventsSeen struct {
	triggered           bool
	atLeastOneShown     map[response.EditorCompletionSource]bool
	requested           bool
	requestedExpected   bool
	requestedUnexpected bool
	requestedError      bool
}

type bufferState struct {
	lastSeen   map[targetBuffer]*shownInstance // completions seen since update was called
	shown      map[targetBuffer]struct{}       // all completions shown for the current snapshot
	buffer     buffer
	eventsSeen eventsSeen // the events that have been seen between buffer updates
}

func (s *bufferState) update(b buffer) *shownInstance {
	if b == s.buffer {
		return nil
	}
	s.buffer = b
	s.eventsSeen = eventsSeen{
		atLeastOneShown: make(map[response.EditorCompletionSource]bool),
	}

	defer func() {
		s.lastSeen = make(map[targetBuffer]*shownInstance)
	}()

	targetBuffer := targetBuffer{
		hash: hash(b.Text()),
	}
	if inst, exists := s.lastSeen[targetBuffer]; exists {
		return inst
	}
	return nil
}

// add returns true if the provided shownInstance corresponds to a newly seen & valid targetBuffer;
// otherwise it returns false.
func (s *bufferState) add(compl data.RCompletion, rank int) (bool, *shownInstance) {
	inst := s.buffer.shownInstance(compl, rank)
	target := s.buffer.targetBuffer(inst)

	switch s.buffer.status(target, inst) {
	case invalidStatus:
		rollbar.Error(fmt.Errorf("completion shown with invalid status"))
		return false, nil
	}

	_, exists := s.shown[target]
	s.shown[target] = struct{}{}
	s.lastSeen[target] = inst
	return !exists, inst
}

func (m *Metrics) recordStat(inst *shownInstance, cType completionType) {
	if cType == completionShown {
		if !inst.lexical {
			return
		}
		if rand.Float64() > shownSampleRate {
			return
		}
	}

	m.cLock.Lock()
	defer m.cLock.Unlock()

	stat := CompletionStat{
		Language:            m.lang,
		CompletionType:      cType,
		Source:              string(inst.source),
		Rank:                inst.rank,
		NumCharsInserted:    len(inst.toInsert()),
		NumCharsReplaced:    len(inst.replacedText),
		NumTokensInserted:   numTokens(inst.toInsert(), m.lang),
		NumTokensReplaced:   numTokens(inst.replacedText, m.lang),
		NumPlaceholderChars: inst.placeholderChars,
		Lexical:             inst.lexical,
		LexicalMetrics:      inst.lexicalMetrics,
	}

	m.complStats = append(m.complStats, stat)

	if len(m.complStats) > maxStats {
		m.flush()
	}
}

func (m *Metrics) flush() {
	clienttelemetry.FastnodeTelemetry("Completion Stats", map[string]interface{}{
		"completion_stats": m.encodeStatsLocked(),
	})
	m.complStats = nil
}

func (m *Metrics) encodeStatsLocked() string {
	var buf bytes.Buffer
	gzw := gzip.NewWriter(&buf)
	json.NewEncoder(gzw).Encode(&m.complStats)
	gzw.Close()
	return base64.StdEncoding.EncodeToString(buf.Bytes())
}

func newBufferState() *bufferState {
	return &bufferState{
		lastSeen: make(map[targetBuffer]*shownInstance),
		shown:    make(map[targetBuffer]struct{}),
	}
}

// --

// compute a fast non-cryptographic hash
func hash(strs ...string) uint64 {
	h := fnv.New64()
	for _, s := range strs {
		h.Write([]byte(s))
	}
	return h.Sum64()
}

func numTokens(s string, l lang.Language) int {
	if l == lang.Python {
		cnt, _ := pythonscanner.Count([]byte(s), pythonscanner.DefaultOptions)
		return cnt
	}

	langLexer, err := lexicalv0.NewLexerForMetrics(l)
	if err != nil {
		return 0
	}
	toks, err := langLexer.Lex([]byte(s))
	if err != nil {
		return 0
	}

	var cnt int
	for _, tok := range toks {
		// TODO(tarak): This filters out the EOF token and semicolon. The semicolon is primarily to
		// remove the automatically inserted semicolons at the end of JS/GO lines that are not
		// rendered, but will also remove them from for loops, etc. We can iterate on this if we like.
		if langLexer.IsType(lexer.EOF, tok) || langLexer.IsType(lexer.SEMICOLON, tok) {
			continue
		}
		cnt++
	}
	return cnt
}

// Counts the number of words in a completion, where words are tokens that are identifiers, keywords, literals, and
// similar interesting tokens. These words are not the same as pythonscanner.Word.
func numWords(s string, l lang.Language) int {
	langLexer, err := lexicalv0.NewLexerForMetrics(l)
	if err != nil {
		return 0
	}
	tokens, err := langLexer.Lex([]byte(s))
	if err != nil {
		return 0
	}
	var wordCount int
	for _, token := range tokens {
		if langLexer.IsType(lexer.IDENT, token) || langLexer.IsType(lexer.KEYWORD, token) || langLexer.IsType(lexer.LITERAL, token) || langLexer.IsType(lexer.IMPORT, token) {
			wordCount++
		}
	}
	return wordCount
}
