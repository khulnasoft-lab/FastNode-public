package titleparser

import (
	"fmt"
	"log"
	"math"
	"regexp"
	"sort"
	"strings"
	"unicode"

	"github.com/khulnasoft-lab/fastnode/fastnode-golib/stl"
)

const (
	// a threshold for determining how similiar (defined by cosine distance on word2vecs) two words
	// need to be to be considered as semantic cousins.
	semanticThr = 0.50

	// part of speech tags
	posCardinalNumber     = "CD"
	posPossessiveEnding   = "POS"
	posAdverb             = "RB"
	posVerbBase           = "VB"
	posVerbPhrase         = "VP"
	posPrepsitionalPhrase = "PP"
	posAdj                = "JJ"
	posComparative        = "JJR"
	posSuperlative        = "JJS"

	posNoun             = "NN"
	posNounPlural       = "NNS"
	posProperNoun       = "NNP"
	posProperNounPlural = "NNPS"
	posVerbPast         = "VBD"
	posVerbGerund       = "VBG"
	posPastParticiple   = "VBN"
	posVerbPresent      = "VBP"
	posVerbPresent3rd   = "VBZ"
)

// regular expressions for parsing title, prelude and code
var (
	// re for prelude
	importAsRegexp = regexp.MustCompile(`.+ as +(.+)`)
	importRegexp   = regexp.MustCompile(`from .+ import +(.+)`)

	// re for code
	funcCallRegexp = regexp.MustCompile(`[a-zA-Z_0-9\.]+\(`)
	keyargsRegexp  = regexp.MustCompile(`((?s).+?)=((?s).+)`)

	// re for title
	useToRegexp = regexp.MustCompile(`[U|u]se .*? to +([^\s]+)`)
	spaceRegexp = regexp.MustCompile(`[\s\xa0]+`)
	rootRegexp  = regexp.MustCompile(`\(ROOT`)
	tagRegexp   = regexp.MustCompile(`\(([^\(\)]+)\)`)
	shapeRegexp = regexp.MustCompile(`(shape *\(([0-9,\s]+)\))`)

	contentInSquares = regexp.MustCompile(` *\[.+\] *`)
)

// semanticCousin is a data structure we use to store a word token (word) and how
// similar it is (score) to another word.
type semanticCousin struct {
	word  string
	score float64
}

type semanticCousins []*semanticCousin

// semanticCousins implement the sort interface. We use a simple sort instead of
// a heap because the number of semantic cousins a word may have is usually < 10.
func (sc semanticCousins) Len() int           { return len(sc) }
func (sc semanticCousins) Less(i, j int) bool { return sc[i].score < sc[j].score }
func (sc semanticCousins) Swap(i, j int)      { sc[j], sc[i] = sc[i], sc[j] }

// preprocessTitle preprocesses the title generated by the curator and prepare
// valid input for the parser.
func preprocessTitle(title string) (string, string) {
	// normalize title by removing extra space and back ticks
	title = removeBackTicks(title)

	// copyTitle is a copy of the normalized title generated by the curator
	copyTitle := title

	// remove square brackets to generate valid input for the parser
	title = removeSquareBrackets(title)
	title = removeExtraSpace(title)

	return title, copyTitle
}

// importedMethods returns the methods that are imported in a code example by
// checking the prelude.
func importedMethods(prelude string) []string {
	var methods []string
	for _, l := range strings.Split(prelude, "\n") {
		if m := importRegexp.FindStringSubmatch(l); len(m) > 0 {
			for _, s := range strings.Split(m[1], ",") {
				if as := importAsRegexp.FindStringSubmatch(strings.TrimSpace(s)); len(as) > 0 {
					methods = append(methods, strings.TrimSpace(as[1]))
				} else {
					methods = append(methods, strings.TrimSpace(s))
				}
			}
		}
	}
	return methods
}

// argsOfFuncs returns arguments for the imported functions
// argsOfFuncs doesn't return args of nested functions, so for a function call:
// test(array(3, 4, 5)) (and if both test and array are imported functions), (3, 4, 5) won't
// be parsed since it's nested inside test().
func argsOfFuncs(code string, exampleOf []string) []*arg {
	var args []*arg
	m := funcCallRegexp.FindAllStringSubmatchIndex(code, -1)
	if m == nil {
		return args
	}
	pos := -1
	for _, index := range m {
		if index[0] <= pos {
			continue
		}
		funcname := code[index[0] : index[1]-1]
		argstr, offset := findArgs(code[index[1]-1:])
		if strList(exampleOf).findAny(strings.Split(funcname, ".")) {
			args = append(args, parseArgs(argstr)...)
		} else {
			args = append(args, argsOfFuncs(argstr, exampleOf)...)
		}
		pos = index[0] + offset
	}
	return args
}

// findArgs returns the parameters of a function call ignoring unbalanced parentheses.
func findArgs(code string) (string, int) {
	var text string
	var parenCount int
	for i, c := range code {
		text += string(c)
		switch c {
		case '(', '[', '{':
			parenCount++
		case ')', ']', '}':
			parenCount--
			if parenCount == 0 {
				for len(text) > 0 && string(text[0]) == "(" && string(text[len(text)-1]) == ")" {
					text = text[1 : len(text)-1]
				}
				return text, i
			}
		}
	}
	return "", len(text)
}

// parseArgs parses the arguments of a function. For example, for a function call like this:
// makeExample(3, 5, func = test(1, 2, 3), dtype = 'float', axis = 0), parseArgs should return
// five arg objects as follows.
// {key: "", val: 3},
// {key: "", val: 5},
// {key: 'func', val: 'test(1, 2, 3)'},
// {key = 'dtype', val: "'float"},
// {key: "axis", val: 0}
// If the function call is syntactically invalid, for example, it has unbalanced number of parentheses,
// then parseArgs return nil.
func parseArgs(code string) []*arg {
	var args []*arg
	var text string
	var parenCount int
	for _, c := range code {
		switch c {
		case '(', '[', '{':
			text += string(c)
			parenCount++
		case ')', ']', '}':
			text += string(c)
			parenCount--
		case ',':
			if parenCount == 0 {
				args = append(args, newArg(text))
				text = ""
			} else {
				text += string(c)
			}
		default:
			text += string(c)
		}
	}
	if parenCount != 0 {
		return nil
	}
	if text != "" {
		args = append(args, newArg(text))
	}
	return args
}

// newArg return a pointer to a newly instantiated arg obj.
func newArg(s string) *arg {
	if m := keyargsRegexp.FindStringSubmatch(s); len(m) > 0 {
		return &arg{
			key: strings.Trim(m[1], " \n"),
			val: strings.Trim(m[2], " \n"),
		}
	}
	return &arg{
		val: strings.Trim(s, " \n"),
	}
}

// similarWords returns a list of words that are semantically similar to w, sorted
// according to their similarity scores.
func similarWords(w string, verblist strList, word2vecMap map[string][]float64) []string {
	var wordscores []*semanticCousin
	for _, v := range verblist {
		if score := cosineSim(word2vecMap[v], word2vecMap[w]); score > semanticThr {
			wordscores = append(wordscores, &semanticCousin{
				word:  v,
				score: score,
			})
		}
	}
	sort.Sort(sort.Reverse(semanticCousins(wordscores)))
	var words []string
	for _, ws := range wordscores {
		words = append(words, ws.word)
	}
	return words
}

func substringOverlap(target string, tags []*token) bool {
	for _, t := range tags {
		switch t.partofspeech {
		case posNoun, posNounPlural, posProperNoun, posProperNounPlural,
			posVerbPast, posVerbGerund, posPastParticiple, posVerbPresent, posVerbPresent3rd:
			if ok, _ := regexp.MatchString(t.text, target); ok {
				log.Println(t.text, target)
				return true
			}
		}
	}
	return false
}

// missingSpecs finds whether the title generated by the curators misses any square brackets.
// The algorithm skips all spaces in the title generated by the curator
// and the standard title (constructed based on the parse tree), and does char-based alignment. If it
// finds square brackets in the standard title and not in the curator-generated title, then there
// are missing square brackets.
func missingSpecs(curated, standard string) ([]string, error) {
	var ptr1, ptr2 int
	var specs []string
	for ptr1 < len(curated) && ptr2 < len(standard) {
		ptr1, ptr2 = alignWithoutSpace(ptr1, ptr2, curated, standard)
		if ptr1 >= len(curated) || ptr2 >= len(standard) || standard[ptr2] != '[' {
			if ptr1 >= len(curated) && ptr2 >= len(standard) {
				return specs, nil
			}
			return specs, fmt.Errorf("mis-alignment in missingSpecs: '%s' v.s. '%s'", curated, standard)
		}
		start := ptr1
		ptr1, ptr2 = alignWithoutSpace(ptr1, ptr2+1, curated, standard)
		ptr2++
		specs = append(specs, strings.TrimSpace(curated[start:ptr1]))
	}
	return specs, nil
}

// alignWithoutSpace alings two strings char-by-char until two strings diverge (except
// spaces).
func alignWithoutSpace(ptr1, ptr2 int, str1, str2 string) (int, int) {
	for ptr1 < len(str1) && ptr2 < len(str2) {
		for ; ptr1 < len(str1) && str1[ptr1] == ' '; ptr1++ {
		}
		for ; ptr2 < len(str2) && str2[ptr2] == ' '; ptr2++ {
		}
		if ptr1 >= len(str1) || ptr2 >= len(str2) {
			return ptr1, ptr2
		}
		if str1[ptr1] != str2[ptr2] {
			return ptr1, ptr2
		}
		ptr1++
		ptr2++
	}
	return ptr1, ptr2
}

// cosineSim returns the cosine similarity of two vectors.
func cosineSim(qVec, pVec []float64) float64 {
	if len(qVec) != len(pVec) {
		return 0
	}
	var sum, qNorm, pNorm float64
	for i, q := range qVec {
		sum += q * pVec[i]
		qNorm += q * q
		pNorm += pVec[i] * pVec[i]
	}
	if qNorm == 0 || pNorm == 0 {
		return -1.0
	}
	return sum / (math.Sqrt(qNorm) * math.Sqrt(pNorm))
}

func numSentences(parse string) int {
	return len(rootRegexp.FindAllString(parse, -1))
}

func startsWithBrackets(s string) bool {
	s = strings.TrimSpace(s)
	if len(s) > 0 {
		switch s[0] {
		case '[', '{', '(':
			return true
		}
	}
	return false
}

func findPossession(tokens []*token) (string, bool) {
	for i, t := range tokens {
		if t.partofspeech == posPossessiveEnding {
			text := t.text
			if i > 0 {
				text = tokens[i-1].text + text
			}
			return text, true
		}
	}
	return "", false
}

func findContraction(tokens []*token) (string, bool) {
	for i, t := range tokens {
		if t.partofspeech == posAdverb && strings.Contains(t.text, "'") {
			text := t.text
			if i > 0 {
				text = tokens[i-1].text + text
			}
			return text, true
		}
	}
	return "", false
}

func isVerb(e *token) bool {
	return e.partofspeech == posVerbBase
}

func isSpecialChar(t string) bool {
	t = strings.TrimSpace(t)
	if len(t) == 1 {
		return !unicode.IsDigit(rune(t[0])) && !unicode.IsLetter(rune(t[0]))
	}
	return t == "'s" || t == "'t" || t == "'m" || t == "'re" || t == "'d" || t == "'ve"
}

// parseTags returns the pos tag for each word token in the parse tree.
func parseTags(parse string) []*token {
	var tags []*token
	m := tagRegexp.FindAllStringSubmatch(parse, -1)
	for _, t := range m {
		tokens := strings.Split(t[1], " ")
		tags = append(tags, &token{
			partofspeech: tokens[0],
			text:         tokens[1],
		})
	}
	return tags
}

// expectedTitle constructs the standard (or the gold-standard)
// title from a parse tree. For example, for the parse tree
// "(ROOT (S (VP (VB Construct) (NP (NP (DT a) (NN 1D) (NN array)) (PP (IN of) (NP (NN type) (`` `) (NN int16))))) (`` `)))",
// the function should return Construct a 1D array [of type int16].
// The implementation utilizes a stack struct.
func expectedTitle(parse string) string {
	stack := new(stl.Stack)

	var fullTitle string
	var isPosTag bool
	var pos, text string

	for _, c := range parse {
		switch c {
		case '(':
			isPosTag = true
		case ' ', '\n':
			isPosTag = false
			if pos != "" {
				stack.Push(token{
					partofspeech: pos,
				})
				pos = ""
			}
		case ')':
			e := stack.Pop().(token)
			if text != "" {
				text = normalizeSymbolCode(text)
				connector := " "
				// avoid extra space, for example `( 2 , 3 )`, because we prefer `(2, 3)`.
				if isSpecialChar(e.text) || isSpecialChar(text) {
					connector = ""
				}
				e.text = strings.TrimSpace(e.text + connector + text)
			}
			// add square brackets around prepositional phrases. avoid nested square brackets.
			if e.partofspeech == posPrepsitionalPhrase {
				squareIndex := strings.Index(e.text, "[")
				if squareIndex == -1 {
					e.text = "[" + e.text + "]"
				} else {
					e.text = "[" + strings.TrimSpace(e.text[:squareIndex]) + "] " + e.text[squareIndex:]
				}
			}
			if stack.Len() == 0 {
				fullTitle = e.text
			} else {
				t := stack.Pop().(token)
				t.text = normalizeSymbolCode(t.text)
				connector := " "
				if isSpecialChar(t.text) || isSpecialChar(e.text) {
					connector = ""
				}
				t.text = strings.TrimSpace(t.text + connector + e.text)
				stack.Push(t)
			}
			text = ""
		default:
			if isPosTag {
				pos += string(c)
			} else {
				text += string(c)
			}
		}
	}
	return fullTitle
}

// verbPhrases returns all the verbphrases in a title
func verbPhrases(parse string) []string {
	stack := new(stl.Stack)

	var vps []string
	var isPosTag bool
	var tag, text string

	for _, c := range parse {
		switch c {
		case '(':
			isPosTag = true
		case ' ', '\n':
			isPosTag = false
			if tag != "" {
				stack.Push(token{
					partofspeech: tag,
				})
				tag = ""
			}
		case ')':
			e := stack.Pop().(token)
			if text != "" {
				text = normalizeSymbolCode(text)
				connector := " "
				if isSpecialChar(e.text) || isSpecialChar(text) {
					connector = ""
				}
				e.text = strings.TrimSpace(e.text + connector + text)
			}
			if e.partofspeech == posVerbPhrase {
				vps = append(vps, e.text)
			}
			if stack.Len() > 0 {
				t := stack.Pop().(token)
				t.text = normalizeSymbolCode(t.text)
				connector := " "
				if isSpecialChar(t.text) || isSpecialChar(e.text) {
					connector = ""
				}
				t.text = strings.TrimSpace(t.text + connector + e.text)
				stack.Push(t)
			}
			text = ""
		default:
			if isPosTag {
				tag += string(c)
			} else {
				text += string(c)
			}
		}
	}
	return vps
}

// -- utility functions for normalizing text
func removeQuotes(text string) string {
	return strings.Trim(text, "'\"")
}

func removeExtraSpace(query string) string {
	query = strings.TrimSpace(query)
	return spaceRegexp.ReplaceAllString(query, " ")
}

func removeBackTicks(text string) string {
	return strings.Replace(text, "`", "", -1)
}

func removeSquareBrackets(text string) string {
	text = strings.Replace(text, "[", "", -1)
	text = strings.Replace(text, "]", "", -1)
	return text
}

func normalizeQuotes(text string) string {
	text = strings.Replace(text, "``", "\"", -1)
	text = strings.Replace(text, "''", "\"", -1)
	text = strings.Replace(text, "`", "'", -1)
	return text
}

func normalizeSymbolCode(text string) string {
	switch text {
	case "-LRB-":
		return "("
	case "-RRB-":
		return ")"
	case "-LSB-":
		return "["
	case "-RSB-":
		return "]"
	case "-LCB-":
		return "{"
	case "-RCB-":
		return "}"
	default:
		return text
	}
}

// -- misc utility functions

// printViolations is only for local debugging purpose
func printViolations(violations []*TitleViolation) {
	for _, v := range violations {
		fmt.Println("[title linter warning]:", v.Message)
	}
	fmt.Println("=================")
}
