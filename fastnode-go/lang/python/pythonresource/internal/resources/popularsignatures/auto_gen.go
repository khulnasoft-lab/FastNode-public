package popularsignatures

// Code generated by github.com/tinylib/msgp DO NOT EDIT.

import (
	"github.com/tinylib/msgp/msgp"
)

// DecodeMsg implements msgp.Decodable
func (z *Entity) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0002 uint32
	zb0002, err = dc.ReadArrayHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if cap((*z)) >= int(zb0002) {
		(*z) = (*z)[:zb0002]
	} else {
		(*z) = make(Entity, zb0002)
	}
	for zb0001 := range *z {
		if dc.IsNil() {
			err = dc.ReadNil()
			if err != nil {
				err = msgp.WrapError(err, zb0001)
				return
			}
			(*z)[zb0001] = nil
		} else {
			if (*z)[zb0001] == nil {
				(*z)[zb0001] = new(Signature)
			}
			err = (*z)[zb0001].DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, zb0001)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z Entity) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteArrayHeader(uint32(len(z)))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0003 := range z {
		if z[zb0003] == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z[zb0003].EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, zb0003)
				return
			}
		}
	}
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z Entity) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize
	for zb0003 := range z {
		if z[zb0003] == nil {
			s += msgp.NilSize
		} else {
			s += z[zb0003].Msgsize()
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ID) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0001 uint32
	zb0001, err = dc.ReadArrayHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if zb0001 != 2 {
		err = msgp.ArrayError{Wanted: 2, Got: zb0001}
		return
	}
	z.ID, err = dc.ReadString()
	if err != nil {
		err = msgp.WrapError(err, "ID")
		return
	}
	{
		var zb0002 int
		zb0002, err = dc.ReadInt()
		if err != nil {
			err = msgp.WrapError(err, "Lang")
			return
		}
		z.Lang = Language(zb0002)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z ID) EncodeMsg(en *msgp.Writer) (err error) {
	// array header, size 2
	err = en.Append(0x92)
	if err != nil {
		return
	}
	err = en.WriteString(z.ID)
	if err != nil {
		err = msgp.WrapError(err, "ID")
		return
	}
	err = en.WriteInt(int(z.Lang))
	if err != nil {
		err = msgp.WrapError(err, "Lang")
		return
	}
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z ID) Msgsize() (s int) {
	s = 1 + msgp.StringPrefixSize + len(z.ID) + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Language) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 int
		zb0001, err = dc.ReadInt()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = Language(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z Language) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteInt(int(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z Language) Msgsize() (s int) {
	s = msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *LanguageSignatureDetails) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0001 uint32
	zb0001, err = dc.ReadArrayHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if zb0001 != 1 {
		err = msgp.ArrayError{Wanted: 1, Got: zb0001}
		return
	}
	if dc.IsNil() {
		err = dc.ReadNil()
		if err != nil {
			err = msgp.WrapError(err, "Python")
			return
		}
		z.Python = nil
	} else {
		if z.Python == nil {
			z.Python = new(PythonSignatureDetails)
		}
		var zb0002 uint32
		zb0002, err = dc.ReadArrayHeader()
		if err != nil {
			err = msgp.WrapError(err, "Python")
			return
		}
		if zb0002 != 1 {
			err = msgp.ArrayError{Wanted: 1, Got: zb0002}
			return
		}
		var zb0003 uint32
		zb0003, err = dc.ReadArrayHeader()
		if err != nil {
			err = msgp.WrapError(err, "Python", "Kwargs")
			return
		}
		if cap(z.Python.Kwargs) >= int(zb0003) {
			z.Python.Kwargs = (z.Python.Kwargs)[:zb0003]
		} else {
			z.Python.Kwargs = make([]*ParameterExample, zb0003)
		}
		for za0001 := range z.Python.Kwargs {
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Python", "Kwargs", za0001)
					return
				}
				z.Python.Kwargs[za0001] = nil
			} else {
				if z.Python.Kwargs[za0001] == nil {
					z.Python.Kwargs[za0001] = new(ParameterExample)
				}
				err = z.Python.Kwargs[za0001].DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Python", "Kwargs", za0001)
					return
				}
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *LanguageSignatureDetails) EncodeMsg(en *msgp.Writer) (err error) {
	// array header, size 1
	err = en.Append(0x91)
	if err != nil {
		return
	}
	if z.Python == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		// array header, size 1
		err = en.Append(0x91)
		if err != nil {
			return
		}
		err = en.WriteArrayHeader(uint32(len(z.Python.Kwargs)))
		if err != nil {
			err = msgp.WrapError(err, "Python", "Kwargs")
			return
		}
		for za0001 := range z.Python.Kwargs {
			if z.Python.Kwargs[za0001] == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = z.Python.Kwargs[za0001].EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "Python", "Kwargs", za0001)
					return
				}
			}
		}
	}
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *LanguageSignatureDetails) Msgsize() (s int) {
	s = 1
	if z.Python == nil {
		s += msgp.NilSize
	} else {
		s += 1 + msgp.ArrayHeaderSize
		for za0001 := range z.Python.Kwargs {
			if z.Python.Kwargs[za0001] == nil {
				s += msgp.NilSize
			} else {
				s += z.Python.Kwargs[za0001].Msgsize()
			}
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ParameterExample) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0001 uint32
	zb0001, err = dc.ReadArrayHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if zb0001 != 2 {
		err = msgp.ArrayError{Wanted: 2, Got: zb0001}
		return
	}
	z.Name, err = dc.ReadString()
	if err != nil {
		err = msgp.WrapError(err, "Name")
		return
	}
	var zb0002 uint32
	zb0002, err = dc.ReadArrayHeader()
	if err != nil {
		err = msgp.WrapError(err, "Types")
		return
	}
	if cap(z.Types) >= int(zb0002) {
		z.Types = (z.Types)[:zb0002]
	} else {
		z.Types = make([]*ParameterTypeExample, zb0002)
	}
	for za0001 := range z.Types {
		if dc.IsNil() {
			err = dc.ReadNil()
			if err != nil {
				err = msgp.WrapError(err, "Types", za0001)
				return
			}
			z.Types[za0001] = nil
		} else {
			if z.Types[za0001] == nil {
				z.Types[za0001] = new(ParameterTypeExample)
			}
			err = z.Types[za0001].DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "Types", za0001)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *ParameterExample) EncodeMsg(en *msgp.Writer) (err error) {
	// array header, size 2
	err = en.Append(0x92)
	if err != nil {
		return
	}
	err = en.WriteString(z.Name)
	if err != nil {
		err = msgp.WrapError(err, "Name")
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Types)))
	if err != nil {
		err = msgp.WrapError(err, "Types")
		return
	}
	for za0001 := range z.Types {
		if z.Types[za0001] == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.Types[za0001].EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "Types", za0001)
				return
			}
		}
	}
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ParameterExample) Msgsize() (s int) {
	s = 1 + msgp.StringPrefixSize + len(z.Name) + msgp.ArrayHeaderSize
	for za0001 := range z.Types {
		if z.Types[za0001] == nil {
			s += msgp.NilSize
		} else {
			s += z.Types[za0001].Msgsize()
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ParameterTypeExample) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0001 uint32
	zb0001, err = dc.ReadArrayHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if zb0001 != 4 {
		err = msgp.ArrayError{Wanted: 4, Got: zb0001}
		return
	}
	var zb0002 uint32
	zb0002, err = dc.ReadArrayHeader()
	if err != nil {
		err = msgp.WrapError(err, "ID")
		return
	}
	if zb0002 != 2 {
		err = msgp.ArrayError{Wanted: 2, Got: zb0002}
		return
	}
	z.ID.ID, err = dc.ReadString()
	if err != nil {
		err = msgp.WrapError(err, "ID", "ID")
		return
	}
	{
		var zb0003 int
		zb0003, err = dc.ReadInt()
		if err != nil {
			err = msgp.WrapError(err, "ID", "Lang")
			return
		}
		z.ID.Lang = Language(zb0003)
	}
	z.Name, err = dc.ReadString()
	if err != nil {
		err = msgp.WrapError(err, "Name")
		return
	}
	var zb0004 uint32
	zb0004, err = dc.ReadArrayHeader()
	if err != nil {
		err = msgp.WrapError(err, "Examples")
		return
	}
	if cap(z.Examples) >= int(zb0004) {
		z.Examples = (z.Examples)[:zb0004]
	} else {
		z.Examples = make([]string, zb0004)
	}
	for za0001 := range z.Examples {
		z.Examples[za0001], err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err, "Examples", za0001)
			return
		}
	}
	z.Frequency, err = dc.ReadFloat64()
	if err != nil {
		err = msgp.WrapError(err, "Frequency")
		return
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *ParameterTypeExample) EncodeMsg(en *msgp.Writer) (err error) {
	// array header, size 4
	// array header, size 2
	err = en.Append(0x94, 0x92)
	if err != nil {
		return
	}
	err = en.WriteString(z.ID.ID)
	if err != nil {
		err = msgp.WrapError(err, "ID", "ID")
		return
	}
	err = en.WriteInt(int(z.ID.Lang))
	if err != nil {
		err = msgp.WrapError(err, "ID", "Lang")
		return
	}
	err = en.WriteString(z.Name)
	if err != nil {
		err = msgp.WrapError(err, "Name")
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Examples)))
	if err != nil {
		err = msgp.WrapError(err, "Examples")
		return
	}
	for za0001 := range z.Examples {
		err = en.WriteString(z.Examples[za0001])
		if err != nil {
			err = msgp.WrapError(err, "Examples", za0001)
			return
		}
	}
	err = en.WriteFloat64(z.Frequency)
	if err != nil {
		err = msgp.WrapError(err, "Frequency")
		return
	}
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ParameterTypeExample) Msgsize() (s int) {
	s = 1 + 1 + msgp.StringPrefixSize + len(z.ID.ID) + msgp.IntSize + msgp.StringPrefixSize + len(z.Name) + msgp.ArrayHeaderSize
	for za0001 := range z.Examples {
		s += msgp.StringPrefixSize + len(z.Examples[za0001])
	}
	s += msgp.Float64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *PythonSignatureDetails) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0001 uint32
	zb0001, err = dc.ReadArrayHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if zb0001 != 1 {
		err = msgp.ArrayError{Wanted: 1, Got: zb0001}
		return
	}
	var zb0002 uint32
	zb0002, err = dc.ReadArrayHeader()
	if err != nil {
		err = msgp.WrapError(err, "Kwargs")
		return
	}
	if cap(z.Kwargs) >= int(zb0002) {
		z.Kwargs = (z.Kwargs)[:zb0002]
	} else {
		z.Kwargs = make([]*ParameterExample, zb0002)
	}
	for za0001 := range z.Kwargs {
		if dc.IsNil() {
			err = dc.ReadNil()
			if err != nil {
				err = msgp.WrapError(err, "Kwargs", za0001)
				return
			}
			z.Kwargs[za0001] = nil
		} else {
			if z.Kwargs[za0001] == nil {
				z.Kwargs[za0001] = new(ParameterExample)
			}
			err = z.Kwargs[za0001].DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "Kwargs", za0001)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *PythonSignatureDetails) EncodeMsg(en *msgp.Writer) (err error) {
	// array header, size 1
	err = en.Append(0x91)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Kwargs)))
	if err != nil {
		err = msgp.WrapError(err, "Kwargs")
		return
	}
	for za0001 := range z.Kwargs {
		if z.Kwargs[za0001] == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.Kwargs[za0001].EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "Kwargs", za0001)
				return
			}
		}
	}
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *PythonSignatureDetails) Msgsize() (s int) {
	s = 1 + msgp.ArrayHeaderSize
	for za0001 := range z.Kwargs {
		if z.Kwargs[za0001] == nil {
			s += msgp.NilSize
		} else {
			s += z.Kwargs[za0001].Msgsize()
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Signature) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0001 uint32
	zb0001, err = dc.ReadArrayHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if zb0001 != 3 {
		err = msgp.ArrayError{Wanted: 3, Got: zb0001}
		return
	}
	var zb0002 uint32
	zb0002, err = dc.ReadArrayHeader()
	if err != nil {
		err = msgp.WrapError(err, "Args")
		return
	}
	if cap(z.Args) >= int(zb0002) {
		z.Args = (z.Args)[:zb0002]
	} else {
		z.Args = make([]*ParameterExample, zb0002)
	}
	for za0001 := range z.Args {
		if dc.IsNil() {
			err = dc.ReadNil()
			if err != nil {
				err = msgp.WrapError(err, "Args", za0001)
				return
			}
			z.Args[za0001] = nil
		} else {
			if z.Args[za0001] == nil {
				z.Args[za0001] = new(ParameterExample)
			}
			err = z.Args[za0001].DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "Args", za0001)
				return
			}
		}
	}
	err = z.LanguageDetails.DecodeMsg(dc)
	if err != nil {
		err = msgp.WrapError(err, "LanguageDetails")
		return
	}
	z.Frequency, err = dc.ReadFloat64()
	if err != nil {
		err = msgp.WrapError(err, "Frequency")
		return
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Signature) EncodeMsg(en *msgp.Writer) (err error) {
	// array header, size 3
	err = en.Append(0x93)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Args)))
	if err != nil {
		err = msgp.WrapError(err, "Args")
		return
	}
	for za0001 := range z.Args {
		if z.Args[za0001] == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.Args[za0001].EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "Args", za0001)
				return
			}
		}
	}
	err = z.LanguageDetails.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "LanguageDetails")
		return
	}
	err = en.WriteFloat64(z.Frequency)
	if err != nil {
		err = msgp.WrapError(err, "Frequency")
		return
	}
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Signature) Msgsize() (s int) {
	s = 1 + msgp.ArrayHeaderSize
	for za0001 := range z.Args {
		if z.Args[za0001] == nil {
			s += msgp.NilSize
		} else {
			s += z.Args[za0001].Msgsize()
		}
	}
	s += z.LanguageDetails.Msgsize() + msgp.Float64Size
	return
}
