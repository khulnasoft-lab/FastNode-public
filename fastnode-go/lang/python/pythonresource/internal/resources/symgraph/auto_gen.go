package symgraph

// Code generated by github.com/tinylib/msgp DO NOT EDIT.

import (
	"github.com/tinylib/msgp/msgp"
)

// DecodeMsg implements msgp.Decodable
func (z *DottedPath) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0001 uint32
	zb0001, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if zb0001 != 2 {
		err = msgp.ArrayError{Wanted: 2, Got: zb0001}
		return
	}
	z.Hash, err = dc.ReadUint64()
	if err != nil {
		return
	}
	var zb0002 uint32
	zb0002, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if cap(z.Parts) >= int(zb0002) {
		z.Parts = (z.Parts)[:zb0002]
	} else {
		z.Parts = make([]String, zb0002)
	}
	for za0001 := range z.Parts {
		err = z.Parts[za0001].DecodeMsg(dc)
		if err != nil {
			return
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *DottedPath) EncodeMsg(en *msgp.Writer) (err error) {
	// array header, size 2
	err = en.Append(0x92)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.Hash)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Parts)))
	if err != nil {
		return
	}
	for za0001 := range z.Parts {
		err = z.Parts[za0001].EncodeMsg(en)
		if err != nil {
			return
		}
	}
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DottedPath) Msgsize() (s int) {
	s = 1 + msgp.Uint64Size + msgp.ArrayHeaderSize
	for za0001 := range z.Parts {
		s += z.Parts[za0001].Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Graph) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0004 uint32
	zb0004, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	if (*z) == nil {
		(*z) = make(Graph, zb0004)
	} else if len((*z)) > 0 {
		for key := range *z {
			delete((*z), key)
		}
	}
	for zb0004 > 0 {
		zb0004--
		var zb0001 string
		var zb0002 []Node
		zb0001, err = dc.ReadString()
		if err != nil {
			return
		}
		var zb0005 uint32
		zb0005, err = dc.ReadArrayHeader()
		if err != nil {
			return
		}
		if cap(zb0002) >= int(zb0005) {
			zb0002 = (zb0002)[:zb0005]
		} else {
			zb0002 = make([]Node, zb0005)
		}
		for zb0003 := range zb0002 {
			err = zb0002[zb0003].DecodeMsg(dc)
			if err != nil {
				return
			}
		}
		(*z)[zb0001] = zb0002
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z Graph) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteMapHeader(uint32(len(z)))
	if err != nil {
		return
	}
	for zb0006, zb0007 := range z {
		err = en.WriteString(zb0006)
		if err != nil {
			return
		}
		err = en.WriteArrayHeader(uint32(len(zb0007)))
		if err != nil {
			return
		}
		for zb0008 := range zb0007 {
			err = zb0007[zb0008].EncodeMsg(en)
			if err != nil {
				return
			}
		}
	}
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z Graph) Msgsize() (s int) {
	s = msgp.MapHeaderSize
	if z != nil {
		for zb0006, zb0007 := range z {
			_ = zb0007
			s += msgp.StringPrefixSize + len(zb0006) + msgp.ArrayHeaderSize
			for zb0008 := range zb0007 {
				s += zb0007[zb0008].Msgsize()
			}
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Kind) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 int
		zb0001, err = dc.ReadInt()
		if err != nil {
			return
		}
		(*z) = Kind(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z Kind) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteInt(int(z))
	if err != nil {
		return
	}
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z Kind) Msgsize() (s int) {
	s = msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Node) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0001 uint32
	zb0001, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if zb0001 != 5 {
		err = msgp.ArrayError{Wanted: 5, Got: zb0001}
		return
	}
	var zb0002 uint32
	zb0002, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if zb0002 != 2 {
		err = msgp.ArrayError{Wanted: 2, Got: zb0002}
		return
	}
	z.Canonical.Hash, err = dc.ReadUint64()
	if err != nil {
		return
	}
	var zb0003 uint32
	zb0003, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if cap(z.Canonical.Parts) >= int(zb0003) {
		z.Canonical.Parts = (z.Canonical.Parts)[:zb0003]
	} else {
		z.Canonical.Parts = make([]String, zb0003)
	}
	for za0001 := range z.Canonical.Parts {
		err = z.Canonical.Parts[za0001].DecodeMsg(dc)
		if err != nil {
			return
		}
	}
	err = z.Children.DecodeMsg(dc)
	if err != nil {
		return
	}
	if dc.IsNil() {
		err = dc.ReadNil()
		if err != nil {
			return
		}
		z.Type = nil
	} else {
		if z.Type == nil {
			z.Type = new(NodeRef)
		}
		err = z.Type.DecodeMsg(dc)
		if err != nil {
			return
		}
	}
	var zb0004 uint32
	zb0004, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if cap(z.Bases) >= int(zb0004) {
		z.Bases = (z.Bases)[:zb0004]
	} else {
		z.Bases = make([]NodeRef, zb0004)
	}
	for za0002 := range z.Bases {
		err = z.Bases[za0002].DecodeMsg(dc)
		if err != nil {
			return
		}
	}
	{
		var zb0005 int
		zb0005, err = dc.ReadInt()
		if err != nil {
			return
		}
		z.Kind = Kind(zb0005)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Node) EncodeMsg(en *msgp.Writer) (err error) {
	// array header, size 5
	// array header, size 2
	err = en.Append(0x95, 0x92)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.Canonical.Hash)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Canonical.Parts)))
	if err != nil {
		return
	}
	for za0001 := range z.Canonical.Parts {
		err = z.Canonical.Parts[za0001].EncodeMsg(en)
		if err != nil {
			return
		}
	}
	err = z.Children.EncodeMsg(en)
	if err != nil {
		return
	}
	if z.Type == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = z.Type.EncodeMsg(en)
		if err != nil {
			return
		}
	}
	err = en.WriteArrayHeader(uint32(len(z.Bases)))
	if err != nil {
		return
	}
	for za0002 := range z.Bases {
		err = z.Bases[za0002].EncodeMsg(en)
		if err != nil {
			return
		}
	}
	err = en.WriteInt(int(z.Kind))
	if err != nil {
		return
	}
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Node) Msgsize() (s int) {
	s = 1 + 1 + msgp.Uint64Size + msgp.ArrayHeaderSize
	for za0001 := range z.Canonical.Parts {
		s += z.Canonical.Parts[za0001].Msgsize()
	}
	s += z.Children.Msgsize()
	if z.Type == nil {
		s += msgp.NilSize
	} else {
		s += z.Type.Msgsize()
	}
	s += msgp.ArrayHeaderSize
	for za0002 := range z.Bases {
		s += z.Bases[za0002].Msgsize()
	}
	s += msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *NodeRef) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0001 uint32
	zb0001, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if zb0001 != 2 {
		err = msgp.ArrayError{Wanted: 2, Got: zb0001}
		return
	}
	z.Internal, err = dc.ReadInt()
	if err != nil {
		return
	}
	var zb0002 uint32
	zb0002, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if zb0002 != 2 {
		err = msgp.ArrayError{Wanted: 2, Got: zb0002}
		return
	}
	z.External.Hash, err = dc.ReadUint64()
	if err != nil {
		return
	}
	var zb0003 uint32
	zb0003, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if cap(z.External.Parts) >= int(zb0003) {
		z.External.Parts = (z.External.Parts)[:zb0003]
	} else {
		z.External.Parts = make([]String, zb0003)
	}
	for za0001 := range z.External.Parts {
		err = z.External.Parts[za0001].DecodeMsg(dc)
		if err != nil {
			return
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *NodeRef) EncodeMsg(en *msgp.Writer) (err error) {
	// array header, size 2
	err = en.Append(0x92)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Internal)
	if err != nil {
		return
	}
	// array header, size 2
	err = en.Append(0x92)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.External.Hash)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.External.Parts)))
	if err != nil {
		return
	}
	for za0001 := range z.External.Parts {
		err = z.External.Parts[za0001].EncodeMsg(en)
		if err != nil {
			return
		}
	}
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *NodeRef) Msgsize() (s int) {
	s = 1 + msgp.IntSize + 1 + msgp.Uint64Size + msgp.ArrayHeaderSize
	for za0001 := range z.External.Parts {
		s += z.External.Parts[za0001].Msgsize()
	}
	return
}
