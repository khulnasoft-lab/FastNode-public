package main

import (
	"fmt"
	"log"
	"time"

	arg "github.com/alexflint/go-arg"
	"github.com/khulnasoft-lab/fastnode/fastnode-go/lang/python"
	"github.com/khulnasoft-lab/fastnode/fastnode-go/lang/python/pythonanalyzer"
	"github.com/khulnasoft-lab/fastnode/fastnode-go/lang/python/pythonast"
	"github.com/khulnasoft-lab/fastnode/fastnode-go/lang/python/pythonbatch"
	"github.com/khulnasoft-lab/fastnode/fastnode-go/lang/python/pythonresource"
	"github.com/khulnasoft-lab/fastnode/fastnode-go/lang/python/pythonstatic"
	"github.com/khulnasoft-lab/fastnode/fastnode-go/lang/python/pythontracking"
	"github.com/khulnasoft-lab/fastnode/fastnode-go/lang/python/pythontracking/servercontext"
	"github.com/khulnasoft-lab/fastnode/fastnode-go/localfiles/offlineconf"
	"github.com/khulnasoft-lab/fastnode/fastnode-golib/fastnodectx"
	"github.com/khulnasoft-lab/fastnode/fastnode-golib/segment/analyze"
	"github.com/khulnasoft-lab/fastnode/fastnode-golib/segment/segmentsrc"
	"github.com/montanaflynn/stats"
	"github.com/pkg/errors"
)

var (
	trackingBucket = "fastnode-segment-callee-tracking"
	segmentSource  = "zts0PA8B3o"
	// Map of server regions to corresponding localfiles S3 buckets. Omitting non-US regions to minimize latency.
	// TODO(damian): get the bucket name from the log once it contains that
	bucketsByRegion = map[string]string{
		"us-west-1": "fastnode-local-content",
		"us-west-2": "fastnode-local-content-us-west-2",
		"us-east-1": "fastnode-local-content-us-east-1",
		"eastus":    "fastnode-local-content-us-east-1",
		"westus2":   "fastnode-local-content",
	}
)

type memGetter map[string]string

func (m memGetter) Get(key []byte) ([]byte, error) {
	c, ok := m[string(key)]
	if !ok {
		return nil, fmt.Errorf("unable to get key %s", string(key))
	}
	return []byte(c), nil
}

func (m memGetter) Prefetch([][]byte) {}

func main() {
	args := struct {
		NumDays    int
		MaxSamples int
		MaxLibs    int
	}{
		NumDays:    2,
		MaxSamples: 100,
		MaxLibs:    50,
	}
	arg.MustParse(&args)

	loadS := time.Now()

	listings, err := analyze.List(segmentsrc.CalleeTracking)
	if err != nil {
		log.Fatalf("error listing %v: %v", segmentsrc.CalleeTracking, err)
	}

	if len(listings.Dates) > args.NumDays {
		listings.Dates = listings.Dates[len(listings.Dates)-args.NumDays:]
	} else {
		fmt.Printf("we only have %d days of data available\n", len(listings.Dates))
	}

	graph, errc := pythonresource.NewManager(python.DefaultServiceOptions.ResourceManager)
	if err := <-errc; err != nil {
		log.Fatalln("failed to create resource manager: ", err)
	}

	var uris []string
	for _, day := range listings.Dates {
		for _, uri := range day.URIs {
			uris = append(uris, uri)
		}
	}

	events := make(chan *pythontracking.Event, 0)
	var count int
	go func() {
		analyze.Analyze(uris, 8, string(pythontracking.ServerSignatureFailureEvent), func(meta analyze.Metadata, evt *pythontracking.Event) bool {
			if evt == nil {
				return false
			}
			if count >= args.MaxSamples {
				return false
			}
			count++
			events <- evt
			return true
		})
		close(events)
	}()

	fmt.Println("Done loading took ", time.Since(loadS))

	analyzeS := time.Now()

	var durationsNoSitePackages []float64
	var durationsWithSitePackages []float64
	var numLibsSelected []float64
	var unresolvedLibsNoSitePackages []float64
	var unresolvedLibsWithSitePackages []float64
	for evt := range events {
		mgr := offlineconf.GetFileManager(evt.Region)
		if mgr == nil {
			fmt.Println("unable to find file manager for ", evt.Region)
			continue
		}

		bucket, found := bucketsByRegion[evt.Region]
		if !found {
			fmt.Printf("unable to find file bucket for region for region %s", evt.Region)
			continue
		}

		files, err := mgr.List(evt.UserID, evt.MachineID)
		if err != nil {
			fmt.Printf("unable to list files for %d %s\n", evt.UserID, evt.MachineID)
			continue
		}

		startPaths, err := pythonbatch.GetInSameDir(fastnodectx.Background(), evt.Filename, files)
		if err != nil || len(startPaths) == 0 {
			fmt.Printf("unable to select start paths for %d %s %s\n", evt.UserID, evt.MachineID, evt.Filename)
			continue
		}

		doIt := func(maxLibs int) (time.Duration, int, int) {
			selOpts := pythonbatch.DefaultOptions.PathSelection
			selOpts.LibraryFileLimit = maxLibs
			selected, _, err := pythonbatch.Selector{
				Opts:       selOpts,
				Files:      files,
				StartPaths: startPaths,
				Getter:     servercontext.NewLocalFileGetter(bucket, files),
				Graph:      graph,
			}.Select(fastnodectx.Background())
			if err != nil {
				log.Fatalln(errors.Wrapf(err, "error selecting files for %d %s %s\n", evt.UserID, evt.MachineID, evt.Filename))
			}

			ai := pythonstatic.AssemblerInputs{
				Graph: graph,
			}
			opts := pythonstatic.DefaultOptions
			assembly, duration := build(selected, ai, opts)
			unresolved := findAllUnresolvedImports(assembly, graph)

			numLibs := 0
			for _, source := range selected {
				if source.ASTBundle.LibraryPath != "" {
					numLibs++
				}
			}
			return duration, len(unresolved), numLibs
		}

		duration, unresolved, _ := doIt(0)
		durationsNoSitePackages = append(durationsNoSitePackages, float64(duration))
		unresolvedLibsNoSitePackages = append(unresolvedLibsNoSitePackages, float64(unresolved))

		duration, unresolved, libs := doIt(args.MaxLibs)
		durationsWithSitePackages = append(durationsWithSitePackages, float64(duration))
		unresolvedLibsWithSitePackages = append(unresolvedLibsWithSitePackages, float64(unresolved))
		numLibsSelected = append(numLibsSelected, float64(libs))
	}

	fmt.Printf("Analyzed %d local indices in %v\n", len(durationsNoSitePackages), time.Since(analyzeS))

	percentiles := []float64{25, 50, 75, 95}

	fmt.Println("----- No site packages -------")
	fmt.Println("Durations")
	for _, pct := range percentiles {
		v, _ := stats.Percentile(stats.Float64Data(durationsNoSitePackages), pct)
		fmt.Printf("%f: %v\n", pct, time.Duration(int64(v)))
	}
	m, _ := stats.Mean(stats.Float64Data(durationsNoSitePackages))
	fmt.Printf("mean: %v\n", time.Duration(int64(m)))

	fmt.Println("Unresolved lib counts")
	for _, pct := range percentiles {
		v, _ := stats.Percentile(stats.Float64Data(unresolvedLibsNoSitePackages), pct)
		fmt.Printf("%f: %v\n", pct, v)
	}
	m, _ = stats.Mean(stats.Float64Data(unresolvedLibsNoSitePackages))
	fmt.Printf("mean: %v\n", m)

	fmt.Println("----- With site packages -------")
	fmt.Println("Durations")
	for _, pct := range percentiles {
		v, _ := stats.Percentile(stats.Float64Data(durationsWithSitePackages), pct)
		fmt.Printf("%f: %v\n", pct, time.Duration(int64(v)))
	}
	m, _ = stats.Mean(stats.Float64Data(durationsWithSitePackages))
	fmt.Printf("mean: %v\n", time.Duration(int64(m)))

	fmt.Println("Unresolved lib counts")
	for _, pct := range percentiles {
		v, _ := stats.Percentile(stats.Float64Data(unresolvedLibsWithSitePackages), pct)
		fmt.Printf("%f: %v\n", pct, v)
	}
	m, _ = stats.Mean(stats.Float64Data(unresolvedLibsWithSitePackages))
	fmt.Printf("mean: %v\n", m)

	fmt.Println("Num libs selected")
	for _, pct := range percentiles {
		v, _ := stats.Percentile(stats.Float64Data(numLibsSelected), pct)
		fmt.Printf("%f: %v\n", pct, v)
	}
	m, _ = stats.Mean(stats.Float64Data(numLibsSelected))
	fmt.Printf("mean: %v\n", m)
}

func findAllUnresolvedImports(assembly *pythonstatic.Assembly, graph pythonresource.Manager) map[string]bool {
	models := pythonanalyzer.Models{
		Importer: pythonstatic.Importer{
			PythonPaths: assembly.PythonPaths,
			Local:       assembly.Sources,
			Global:      graph,
		},
	}

	unresolved := make(map[string]bool)
	for fn, f := range assembly.Files {

		rast, err := resolve(f.ASTBundle.AST, fn, models)
		if err != nil {
			continue
		}

		findUnresolvedImports(rast, unresolved)
	}

	return unresolved
}

func resolve(ast *pythonast.Module, filename string, models pythonanalyzer.Models) (*pythonanalyzer.ResolvedAST, error) {
	models.Importer.Path = filename
	opts := pythonanalyzer.Options{
		Path: filename,
	}

	var resolved *pythonanalyzer.ResolvedAST
	err := fastnodectx.Background().WithTimeout(10*time.Second, func(ctx fastnodectx.Context) error {
		var err error
		resolved, err = pythonanalyzer.Resolve(ctx, models, ast, opts)
		return err
	})
	return resolved, err
}

func findUnresolvedImports(r *pythonanalyzer.ResolvedAST, unresolved map[string]bool) {
	pythonast.Inspect(r.Root, func(n pythonast.Node) bool {
		switch n := n.(type) {
		case *pythonast.ImportFromStmt:
			if n.Package != nil {
				name := n.Package.Names[0]
				root := r.References[name]
				if root == nil {
					unresolved[name.Ident.Literal] = true
				}
			}
			return false
		case *pythonast.ImportNameStmt:
			for _, clause := range n.Names {
				name := clause.External.Names[0]
				root := r.References[name]
				if root == nil {
					unresolved[name.Ident.Literal] = true
				}
			}
			return false
		default:
			return true
		}
	})
}

func build(sources map[string]*pythonbatch.SourceUnit, ai pythonstatic.AssemblerInputs, opts pythonstatic.Options) (*pythonstatic.Assembly, time.Duration) {
	assembler := pythonstatic.NewAssembler(fastnodectx.Background(), ai, opts)
	for _, source := range sources {
		assembler.AddSource(source.ASTBundle)
	}

	start := time.Now()
	var assembly *pythonstatic.Assembly
	err := fastnodectx.Background().WithTimeout(90*time.Second, func(ctx fastnodectx.Context) error {
		var err error
		assembly, err = assembler.Build(ctx)
		return err
	})
	if err != nil {
		log.Fatal(err)
	}
	return assembly, time.Since(start)
}
