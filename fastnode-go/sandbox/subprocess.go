package sandbox

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"time"
)

// Subprocess represents a command that has been started in a subprocess.
type Subprocess struct {
	command     *exec.Cmd
	timeoutChan <-chan time.Time
	stdoutBuf   *syncBuffer
	stderrBuf   *syncBuffer
	opts        *ProcessOptions
	workingDir  string
}

// StartSubprocess executes a command in a subprocess with the given time and output limits.
func StartSubprocess(opts *ProcessOptions) (*Subprocess, error) {
	// Create the working dir
	workdir, err := ioutil.TempDir("", "")
	if err != nil {
		return nil, err
	}

	// Create any files needed by the program
	err = createFiles(workdir, opts.Files)
	if err != nil {
		return nil, err
	}

	// Set up the command
	var stdoutBuf, stderrBuf syncBuffer
	cmd := exec.Command(opts.Command, opts.Args...)
	cmd.Stdout = &stdoutBuf
	cmd.Stderr = &stderrBuf
	cmd.Stdin = bytes.NewBuffer(opts.StandardInput)
	cmd.Dir = workdir
	for k, v := range opts.EnvironmentVariables {
		cmd.Env = append(cmd.Env, k+"="+v)
	}

	// Start the executable
	if err := cmd.Start(); err != nil {
		return nil, fmt.Errorf("Failed to start python process: %v", err)
	}

	// Construct subprocess and return
	process := Subprocess{
		command:     cmd,
		timeoutChan: opts.Limits.makeTimeoutChannel(),
		stdoutBuf:   &stdoutBuf,
		stderrBuf:   &stderrBuf,
		opts:        opts,
		workingDir:  workdir,
	}

	return &process, nil
}

// Cancel terminates the underlying subprocess and returns output generated so far
func (c *Subprocess) Cancel() ([]byte, []byte) {
	c.kill()
	err := c.command.Wait()
	if err != nil {
		log.Printf("Error waiting for command: %v. Ignoring.", err)
	}
	return c.stdoutBuf.Bytes(), c.stderrBuf.Bytes()
}

// kill terminates the underlying subprocess
func (c *Subprocess) kill() {
	if err := c.command.Process.Kill(); err != nil {
		log.Printf("Failed to kill subprocess: %v. Ignoring.", err)
	}
}

// Wait blocks until one of the following conditions is met:
//  - stdout and stderr are closed and the subprocess itself exits
//  - a time limit is exceeded
//  - an output limit is exceeded
//  - an error (other than EOF) is generated by stdin, stdout, or stderr
func (c *Subprocess) Wait() ([]byte, []byte, error) {
	// Make a cancel channel that will never generate any output
	rescindChan := make(chan error)
	return c.RescindableWait(rescindChan)
}

// RescindableWait blocks until one of the following conditions is met:
//  - stdout and stderr are closed and the subprocess itself exits
//  - a time limit is exceeded
//  - an output limit is exceeded
//  - an error (other than EOF) is generated by stdin, stdout, or stderr
//  - anything is received on the provided channel
func (c *Subprocess) RescindableWait(rescindChan chan error) ([]byte, []byte, error) {
	// Wait for all streams to be closed
	exitChan := make(chan error, 1)
	go func() {
		exitChan <- c.command.Wait()
	}()

	// Create a ticker to check for output limits
	ticker := time.NewTicker(50 * time.Millisecond)
	defer ticker.Stop()

	// Wait for either command to complete or a limit to be exceeded
	var firstErr error
	for {
		select {
		case <-c.timeoutChan:
			if firstErr != nil {
				log.Println("Timeout expired but the subprocess was already killed due to", firstErr)
				continue
			}
			log.Println("Killing subprocess after timeout expired")
			firstErr = &TimeLimitExceeded{c.opts.Limits.Timeout}
			c.kill()

		case <-ticker.C:
			if firstErr != nil {
				continue
			}
			if l, b := c.stdoutBuf.Counts(); c.opts.Limits.exceeded(l, b) {
				log.Printf("Killing subprocess after stdout limit exceeded")
				firstErr = &OutputLimitExceeded{Stream: "stdout"}
				c.kill()
			} else if l, b := c.stderrBuf.Counts(); c.opts.Limits.exceeded(l, b) {
				log.Printf("Killing subprocess after stderr limit exceeded")
				firstErr = &OutputLimitExceeded{Stream: "stderr"}
				c.kill()
			}

		case err := <-rescindChan:
			if firstErr != nil {
				log.Println("Got rescind but the subprocess was already killed due to", firstErr)
				continue
			}
			log.Printf("Killing subprocess after rescind: %v\n", err)
			firstErr = err
			c.kill()

		case err := <-exitChan:
			if err != nil || firstErr != nil {
				log.Printf("Subprocess exited with err=%v (firstErr=%v)", err, firstErr)
			}
			stdout := c.stdoutBuf.Bytes()
			stderr := c.stderrBuf.Bytes()

			// If this was triggered by a output limit or timeout then use that error instead
			if firstErr != nil {
				err = firstErr
			} else if err != nil {
				if exitErr, ok := err.(*exec.ExitError); ok {
					err = &UncleanExit{exitErr, string(stderr)}
				}
			}
			return stdout, stderr, err
		}
	}
}

// Endpoint returns the host:port on which this subprocess can be contacted. This is always equal
// to the port provided to StartSubprocess.
func (c *Subprocess) Endpoint() (string, error) {
	return fmt.Sprintf("127.0.0.1:%d", c.opts.Port), nil
}

// Files gets the files in the working directory of the process. It can be queried any time after
// the process is started and before it is cleaned up.
func (c *Subprocess) Files() (map[string][]byte, error) {
	return collectFiles(c.workingDir)
}

// Cleanup deletes the working directory for the subprocess
func (c *Subprocess) Cleanup() {
	err := os.RemoveAll(c.workingDir)
	if err != nil {
		log.Printf("Error removing working directory: %v. Ignoring.", err)
	}
}
