package websandbox

import (
	"context"
	"crypto/md5"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"strings"
	"sync"

	"github.com/khulnasoft-lab/fastnode/fastnode-golib/licensing"

	"github.com/khulnasoft-lab/fastnode/fastnode-golib/gziphttp"

	"github.com/gorilla/mux"
	"github.com/khulnasoft-lab/fastnode/fastnode-go/lang/python/pythoncomplete/api"
	"github.com/khulnasoft-lab/fastnode/fastnode-go/response"
	"github.com/khulnasoft-lab/fastnode/fastnode-golib/complete/data"
	"github.com/khulnasoft-lab/fastnode/fastnode-golib/fastnodectx"
)

const (
	sandboxCompletionLimit = 7
)

// Server wraps the concept of a "sandbox-node", i.e. a process that responds
// to editor-type events sent from a browser environment
type Server struct {
	options *Options
	api     api.API

	m         sync.Mutex
	recording map[string]map[string][]data.NRCompletion
}

// NewServer creates a Server object
func NewServer(options *Options) *Server {
	return &Server{
		options: options,
		api: api.New(context.Background(), api.Options{
			ResourceManager: options.Services.ResourceManager,
			Models:          options.Services.Models,
			Cloud:           true,
		}, licensing.Pro),
		recording: make(map[string]map[string][]data.NRCompletion),
	}
}

// SetupRoutes sets up the websandbox routes for the given Server
func (s *Server) SetupRoutes(mux *mux.Router) {
	sandbox := mux.PathPrefix("/api/").Subrouter()
	sandbox.HandleFunc("/websandbox/complete", gziphttp.Wrap(s.handleComplete)).Methods("POST")
}

type completionsResponse struct {
	Completions []response.SandboxCompletion `json:"completions"`
}

func (s *Server) handleComplete(w http.ResponseWriter, r *http.Request) {
	var resp data.APIResponse
	defer func() {
		resBuf, _ := json.Marshal(resp)

		if resp.HTTPStatus == 0 {
			resp.HTTPStatus = 500
		}

		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(resp.HTTPStatus)
		w.Write(resBuf)
	}()

	var req data.APIRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		resp.HTTPStatus = http.StatusBadRequest
		resp.Error = "could not decode request"
		return
	}
	err := fastnodectx.FromContext(r.Context(), func(ctx fastnodectx.Context) error {
		resp = s.api.Complete(ctx, s.options.IDCCCompleteOptions, req, nil, nil)
		return nil
	})
	if err != nil {
		resp.Error = err.Error()
		resp.HTTPStatus = http.StatusInternalServerError
		return
	}

	if s.options.SandboxRecordMode {
		pruneDocs(&resp)
		if len(resp.Completions) > sandboxCompletionLimit {
			resp.Completions = resp.Completions[:sandboxCompletionLimit]
		} else if resp.Completions == nil {
			resp.Completions = []data.NRCompletion{}
		}
		s.updateRecording(req, resp.Completions)
	}
}

// updateRecording will update the recording map with the completions provided & write the recording map to disk.
// the recording map is: map[filename (str)] -> map[ cacheID (str) ] -> []completions
func (s *Server) updateRecording(req data.APIRequest, completions []data.NRCompletion) {
	cacheID, err := cacheIDForRequest(req)
	if err != nil {
		log.Fatalln("error creating cacheID:", err)
	}

	// the filename provided in the request corresponds to the "active filename" in the web-sandbox generating
	// the request. this filename is used as the top-level key into the completions cache in the sandbox
	// (see structure of recording map), so we must reconstruct it here by just trimming the leading '/'
	fn := strings.TrimPrefix(req.Filename, "/")

	s.m.Lock()
	defer s.m.Unlock()
	fnCompletions := s.recording[fn]
	if fnCompletions == nil {
		fnCompletions = make(map[string][]data.NRCompletion)
		s.recording[fn] = fnCompletions
	}
	s.recording[fn][cacheID] = completions

	buf, err := json.Marshal(s.recording)
	if err != nil {
		log.Println("error marshalling recording:", err)
		return
	}
	ioutil.WriteFile("completions.json", buf, os.ModePerm)
	log.Println("recording entries:", len(s.recording[fn]))
}

func pruneDocs(result *data.APIResponse) {
	for idx := range result.Completions {
		result.Completions[idx].Docs = data.Documentation{}
	}
}

// cacheIDForRequest should correspond to the cacheID generated by the sandbox here:
// https://github.com/khulnasoft-lab/sandbox-completions/blob/master/sandbox/EditorSandbox/index.js#L472
func cacheIDForRequest(req data.APIRequest) (string, error) {
	var key []interface{}
	key = append(key, req.Buffer.Text())
	key = append(key, req.Selection.Begin)
	key = append(key, req.Selection.End)
	buf, err := json.Marshal(key)
	if err != nil {
		return "", err
	}
	sum := fmt.Sprintf("%x", md5.Sum(buf))
	log.Println("key:", sum, req.Selection.Begin, req.Selection.End)
	return sum, nil
}
