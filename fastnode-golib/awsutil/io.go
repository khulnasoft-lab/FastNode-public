package awsutil

import (
	"bytes"
	"compress/zlib"
	"encoding/base64"
	"encoding/binary"
	"encoding/csv"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"strings"
	"sync"
)

// A byte to indicate the presence of a tag
const tagged = 0x1

// EMRIterator is a wrapper around EMRReader that makes consuming data
// generated by EMRWriter easier to work with.
type EMRIterator struct {
	r     *EMRReader
	err   error
	key   string
	tag   int
	value []byte
}

// NewEMRIterator builds a new EMRIterator from the provided io.Reader.
func NewEMRIterator(r io.Reader) *EMRIterator {
	return &EMRIterator{
		r: NewEMRReader(r),
	}
}

// Next advances the iterator. Next will return false on completion or error. Be sure
// to check Err() to determine if there was a non-EOF error.
func (i *EMRIterator) Next() bool {
	i.key, i.value, i.err = i.r.Read()
	if i.err != nil {
		return false
	}
	if len(i.value) >= 5 && i.value[0] == tagged {
		// Read the tag if it is present
		var tag int32
		i.err = binary.Read(bytes.NewBuffer(i.value[1:5]), binary.LittleEndian, &tag)
		if i.err != nil {
			return false
		}
		i.tag = int(tag)
		i.value = i.value[5:]
	}
	return true
}

// Key returns the key of the record the iterator is currently on.
func (i *EMRIterator) Key() string {
	return i.key
}

// Value returns the value of the record the iterator is currently on.
// NOTE: value is safe to use without copying.
func (i *EMRIterator) Value() []byte {
	return i.value
}

// Tag returns the tag for the record the iterator is currently on.
func (i *EMRIterator) Tag() int {
	return i.tag
}

// Err returns any non-EOF errors.
func (i *EMRIterator) Err() error {
	if i.err == io.EOF {
		return nil
	}
	return i.err
}

// EMRIterateSharded will (in parallel) apply the provided function to every key/value pair
// contained in the provided sharded file. NOTE: the caller is still responsible for writing
// goroutine safe code in the provided goroutine.
func EMRIterateSharded(s *ShardedFile, fn func(string, []byte) error) error {
	var wg sync.WaitGroup
	wg.Add(s.Shards())

	errChan := make(chan error, s.Shards())
	for i := 0; i < s.Shards(); i++ {
		r, err := s.CachedReader(i)
		if err != nil {
			return err
		}
		defer r.Close()

		go func(r io.ReadCloser) {
			defer wg.Done()
			iter := NewEMRIterator(r)
			for iter.Next() {
				err := fn(iter.Key(), iter.Value())
				if err != nil {
					errChan <- err
					return
				}
			}
			errChan <- iter.Err()
		}(r)
	}

	go func() {
		wg.Wait()
		close(errChan)

	}()

	for err := range errChan {
		if err != nil {
			return err
		}
	}

	return nil
}

// EMRReader reads key/value pairs per line, separated by a tab, as expected by the
// AWS ElasticMapReduce framework. This object can read records written by EMRWriter.
type EMRReader struct {
	tr *csv.Reader
}

// NewEMRReader creates a new EMRReader
func NewEMRReader(r io.Reader) *EMRReader {
	tr := csv.NewReader(r)
	tr.Comma = '\t'
	tr.LazyQuotes = true
	return &EMRReader{
		tr: tr,
	}
}

// Read returns the next key and value. If there is no tag present then it will be
// set to zero.
func (r *EMRReader) Read() (key string, value []byte, err error) {
	records, err := r.tr.Read()
	if err != nil {
		return
	}
	if len(records) != 2 {
		err = fmt.Errorf("expected 2 records, got %d", len(records))
		return
	}

	key = records[0]
	encValue := strings.NewReader(records[1])
	dec := base64.NewDecoder(base64.URLEncoding, encValue)
	decomp, err := zlib.NewReader(dec)
	if err != nil {
		return
	}

	value, err = ioutil.ReadAll(decomp)
	return
}

// --

// EMRWriter writes key/value pairs per line, separated by a tab, as expected by the
// AWS ElasticMapReduce framework. We also compress and base64 encode values because
// Hadoop's PipeMap/Reduce can't handle binary data. The data written by an EMRWriter
// can be easily read by an EMRReader or EMRIterator.
type EMRWriter struct {
	tw *csv.Writer
}

// NewEMRWriter returns a new EMRWriter
func NewEMRWriter(w io.Writer) *EMRWriter {
	tw := csv.NewWriter(w)
	tw.Comma = rune('\t')
	return &EMRWriter{
		tw: tw,
	}
}

// Emit writes the provided key and value. The value is zlib compressed and
// encoded in base64 since binary data is not supported by the underlying stream,
// the key is also stripped of any whitespace.
func (w *EMRWriter) Emit(key string, value []byte) error {
	var b bytes.Buffer
	enc := base64.NewEncoder(base64.URLEncoding, &b)
	comp := zlib.NewWriter(enc)
	comp.Write(value)
	comp.Close()
	enc.Close()

	key = strings.TrimSpace(key)
	return w.tw.Write([]string{key, string(b.Bytes())})
}

// EmitWithTag writes the provided key, tag, and value. The value is zlib compressed and
// encoded in base64 since binary data is not supported by the underlying stream.
func (w *EMRWriter) EmitWithTag(key string, tag int, value []byte) error {
	var b bytes.Buffer
	enc := base64.NewEncoder(base64.URLEncoding, &b)
	comp := zlib.NewWriter(enc)
	comp.Write([]byte{tagged})
	binary.Write(comp, binary.LittleEndian, int32(tag))
	comp.Write(value)
	comp.Close()
	enc.Close()

	return w.tw.Write([]string{key, string(b.Bytes())})
}

// Close will flush any bufferd data.
func (w *EMRWriter) Close() error {
	w.tw.Flush()
	return w.tw.Error()
}

// --

// EMRDecoder exposes an interface similar to the decoders in the go standard library
// to read from EMR key/value streams. It makes it possible to do:
//
//   err := serialization.Decode("s3://foo.emr", func (value *Apple) {
//      log.Println(apple)
//   }
//
// If you also want the keys, or if you want the value as a byte slice then you can do:
//
//   var value Apple
//   err := serialization.Decode("s3://foo.emr", func (x *awsutil.KeyValue) {
//      kv.JSONValue(&value)
//      log.Println(x.Key, x.Value)
//   }
type EMRDecoder struct {
	r *EMRReader
}

// NewEMRDecoder constructs an EMR decoder that reads from the given stream
func NewEMRDecoder(r io.Reader) *EMRDecoder {
	return &EMRDecoder{NewEMRReader(r)}
}

// Decode decodes the next item in the EMR stream
func (d *EMRDecoder) Decode(x interface{}) error {
	key, value, err := d.r.Read()
	if err != nil {
		return err
	}

	if kv, ok := x.(*KeyValue); ok {
		kv.Key = key
		kv.Value = value
		return nil
	}
	return json.Unmarshal(value, x)
}

// KeyValue represents a key/value pair in an EMR stream
type KeyValue struct {
	Key   string
	Value []byte
}

// JSONValue decodes the value as a json object.
func (kv KeyValue) JSONValue(x interface{}) error {
	return json.Unmarshal(kv.Value, x)
}
