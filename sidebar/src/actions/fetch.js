import * as request from '../utils/fetch'

export const REPORT_FASTNODED_UNREACHABLE = 'fastnoded is unreachable'
export const REPORT_FASTNODED_REACHABLE = 'fastnoded is reachable again'
export const REPORT_FASTNODED_UNHEALTHY = 'fastnoded is not healthy'

/**
 * helper methods to detect when fastnoded is and is not reachable
 *
 * Intended usage:
 *
 * fetch(url)
 *   .then(resolveBody)
 *   .then(
 *     reportFastnodedReachable(dispatch),
 *     catchFastnodedNotReachable(dispatch)
 *   )
 *
 * Note: this returns the dispatched action, so
 * promise handlers should watch out for this action
 * parameters as a signal for a network error
 */
export const catchFastnodedNotReachable = error => dispatch =>
  dispatch({
    type: REPORT_FASTNODED_UNREACHABLE,
    error,
  })

export const reportFastnodedReachable = response => (dispatch, getState) => {
  const { errors } = getState()
  if (!errors.online) {
    dispatch({
      type: REPORT_FASTNODED_REACHABLE,
    })
  }
  return response
}

//further helper to report if fastnoded is responding, but not healthy
export const catchFastnodedNotHealthy = response => dispatch => {
  dispatch({
    type: REPORT_FASTNODED_UNHEALTHY,
    response,
  })
  return response
}

export const interpretErrorSuccess = ({ response, json, text, type }) => {
  if (response && response.ok) {
    if (json) {
      return { success: true, data: json }
    } else if (text) {
      return { success: true, data: text }
    }
    return { success: true }
  } else if (json) {
    return { success: false, error: json.message || json, status: response.status }
  } else if (text) {
    if (response) {
      return { success: false, error: text, response: response, status: response.status }
    } else {
      return { success: false, error: text }
    }
  }
  return { success: false, status: response.status }
}

/* ==={ METHODS }=== */
/*
 * The below methods simply wrap methods from
 * ../utils/fetch.js so that they can be dispatched and connected
 * to the redux store. In addition, these methods will
 * display a global error when they fail.
 */

const wrapMethod = method => params => dispatch =>
  method(params)
    .then(response => {
      // hack to get around Unresponsive loop generated by 
      // intermittant 502/503s from polling /api/user/accounts
      if(request.isOK(response) || request.ignoreUrlForResponseCode(response)) {
        return dispatch(reportFastnodedReachable(response))
      } else {
        return dispatch(catchFastnodedNotHealthy(response))
      }
    })
    .catch(error => {
      dispatch(catchFastnodedNotReachable(error))
      throw error
    })
    .then(interpretErrorSuccess)

export const GET = wrapMethod(request.GET)
export const POST = wrapMethod(request.POST)
export const PATCH = wrapMethod(request.PATCH)
export const PUT = wrapMethod(request.PUT)
export const DELETE = wrapMethod(request.DELETE)

export const batchFetch = queries => dispatch => {
  return Promise.all(queries.map(dispatch)).then(results => {
    if (results.every(r => r.success)) {
      return {
        success: true,
        data: results.map(r => r.data),
        responses: results.map(r => r.response),
      }
    } else {
      return {
        success: false,
        data: results.map(r => r.data),
        responses: results.map(r => r.response),
      }
    }
  })
}

export const batchFetchSafe = queries => dispatch => {
  return Promise.all(queries.map(dispatch)).then(results => {
    if (results.some(r => r.success)) {
      return {
        success: true,
        data: results.map(r => r.data),
        responses: results.map(r => r.response),
      }
    } else {
      return {
        success: false,
        data: results.map(r => r.data),
        responses: results.map(r => r.response),
      }
    }
  })
}
